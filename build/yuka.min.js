/**
 * The MIT License
 *
 * Copyright Â© 2022 Yuka authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).YUKA={})}(this,(function(t){"use strict";class e{constructor(t,e,s,i,r){this.sender=t,this.receiver=e,this.message=s,this.delay=i,this.data=r}toJSON(){return{type:this.constructor.name,sender:this.sender.uuid,receiver:this.receiver.uuid,message:this.message,delay:this.delay,data:this.data}}fromJSON(t){return this.sender=t.sender,this.receiver=t.receiver,this.message=t.message,this.delay=t.delay,this.data=t.data,this}resolveReferences(t){return this.sender=t.get(this.sender),this.receiver=t.get(this.receiver),this}}class s{static setLevel(t){i=t}static log(...t){i<=s.LEVEL.LOG&&console.log(...t)}static warn(...t){i<=s.LEVEL.WARN&&console.warn(...t)}static error(...t){i<=s.LEVEL.ERROR&&console.error(...t)}}s.LEVEL=Object.freeze({LOG:0,WARN:1,ERROR:2,SILENT:3});let i=s.LEVEL.WARN;class r{constructor(){this.delayedTelegrams=new Array}deliver(t){const e=t.receiver;return!1===e.handleMessage(t)&&s.warn("YUKA.MessageDispatcher: Message not handled by receiver: %o",e),this}dispatch(t,s,i,r,n){const o=new e(t,s,i,r,n);return r<=0?this.deliver(o):this.delayedTelegrams.push(o),this}dispatchDelayedMessages(t){let e=this.delayedTelegrams.length;for(;e--;){const s=this.delayedTelegrams[e];s.delay-=t,s.delay<=0&&(this.deliver(s),this.delayedTelegrams.pop())}return this}clear(){return this.delayedTelegrams.length=0,this}toJSON(){const t={type:this.constructor.name,delayedTelegrams:new Array};for(let e=0,s=this.delayedTelegrams.length;e<s;e++){const s=this.delayedTelegrams[e];t.delayedTelegrams.push(s.toJSON())}return t}fromJSON(t){this.clear();const s=t.delayedTelegrams;for(let t=0,i=s.length;t<i;t++){const i=s[t],r=(new e).fromJSON(i);this.delayedTelegrams.push(r)}return this}resolveReferences(t){const e=this.delayedTelegrams;for(let s=0,i=e.length;s<i;s++){e[s].resolveReferences(t)}return this}}const n=new Array;for(let t=0;t<256;t++)n[t]=(t<16?"0":"")+t.toString(16);class o{static area(t,e,s){return(s.x-t.x)*(e.z-t.z)-(e.x-t.x)*(s.z-t.z)}static argmax(t){const e=Math.max(...t),s=[];for(let i=0,r=t.length;i<r;i++)t[i]===e&&s.push(i);return s}static choice(t,e=null){const s=Math.random();if(null===e)return t[Math.floor(Math.random()*t.length)];{let i=0;const r=t.map(((t,s)=>(i+=e[s],i))).findIndex((t=>t>=s));return t[r]}}static clamp(t,e,s){return Math.max(e,Math.min(s,t))}static generateUUID(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,s=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(n[255&t]+n[t>>8&255]+n[t>>16&255]+n[t>>24&255]+"-"+n[255&e]+n[e>>8&255]+"-"+n[e>>16&15|64]+n[e>>24&255]+"-"+n[63&s|128]+n[s>>8&255]+"-"+n[s>>16&255]+n[s>>24&255]+n[255&i]+n[i>>8&255]+n[i>>16&255]+n[i>>24&255]).toUpperCase()}static randFloat(t,e){return t+Math.random()*(e-t)}static randInt(t,e){return t+Math.floor(Math.random()*(e-t+1))}}class h{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return(new this.constructor).copy(this)}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.x/=t,this.y/=t,this.z/=t,this}divideVectors(t,e){return this.x=t.x/e.x,this.y=t.y/e.y,this.z=t.z/e.z,this}reflect(t){return this.sub(a.copy(t).multiplyScalar(2*this.dot(t)))}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){const e=this.x,s=this.y,i=this.z;return this.x=s*t.z-i*t.y,this.y=i*t.x-e*t.z,this.z=e*t.y-s*t.x,this}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,n=e.x,o=e.y,h=e.z;return this.x=i*h-r*o,this.y=r*n-s*h,this.z=s*o-i*n,this}angleTo(t){const e=Math.sqrt(this.squaredLength()*t.squaredLength());if(0===e)return 0;const s=this.dot(t)/e;return Math.acos(o.clamp(s,-1,1))}length(){return Math.sqrt(this.squaredLength())}squaredLength(){return this.dot(this)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}distanceTo(t){return Math.sqrt(this.squaredDistanceTo(t))}squaredDistanceTo(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return Math.abs(e)+Math.abs(s)+Math.abs(i)}normalize(){return this.divideScalar(this.length()||1)}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,n=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*n,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*n,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*n,this}applyRotation(t){const e=this.x,s=this.y,i=this.z,r=t.x,n=t.y,o=t.z,h=t.w,a=h*e+n*i-o*s,l=h*s+o*e-r*i,c=h*i+r*s-n*e,u=-r*e-n*s-o*i;return this.x=a*h+u*-r+l*-o-c*-n,this.y=l*h+u*-n+c*-r-a*-o,this.z=c*h+u*-o+a*-n-l*-r,this}extractPositionFromMatrix(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}fromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}fromMatrix4Column(t,e){return this.fromArray(t.elements,4*e)}fromSpherical(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}fromArray(t,e=0){return this.x=t[e+0],this.y=t[e+1],this.z=t[e+2],this}toArray(t,e=0){return t[e+0]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}}const a=new h,l=new h(0,1,0),c=new h,u=new h,d=new h,p=new h,g=[2,2,1],m=[1,0,0];class f{constructor(){this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,s,i,r,n,o,h,a){const l=this.elements;return l[0]=t,l[3]=e,l[6]=s,l[1]=i,l[4]=r,l[7]=n,l[2]=o,l[5]=h,l[8]=a,this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}clone(){return(new this.constructor).copy(this)}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[3],h=s[6],a=s[1],l=s[4],c=s[7],u=s[2],d=s[5],p=s[8],g=i[0],m=i[3],f=i[6],y=i[1],x=i[4],w=i[7],S=i[2],v=i[5],b=i[8];return r[0]=n*g+o*y+h*S,r[3]=n*m+o*x+h*v,r[6]=n*f+o*w+h*b,r[1]=a*g+l*y+c*S,r[4]=a*m+l*x+c*v,r[7]=a*f+l*w+c*b,r[2]=u*g+d*y+p*S,r[5]=u*m+d*x+p*v,r[8]=u*f+d*w+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}extractBasis(t,e,s){return t.fromMatrix3Column(this,0),e.fromMatrix3Column(this,1),s.fromMatrix3Column(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,t.y,e.y,s.y,t.z,e.z,s.z),this}lookAt(t,e,s){return c.crossVectors(s,t).normalize(),u.crossVectors(l,e).normalize(),0===u.squaredLength()&&(p.copy(e).addScalar(Number.EPSILON),u.crossVectors(l,p).normalize()),d.crossVectors(e,u).normalize(),y.makeBasis(u,d,e),x.makeBasis(c,s,t),this.multiplyMatrices(y,x.transpose()),this}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getElementIndex(t,e){return 3*t+e}frobeniusNorm(){const t=this.elements;let e=0;for(let s=0;s<9;s++)e+=t[s]*t[s];return Math.sqrt(e)}offDiagonalFrobeniusNorm(){const t=this.elements;let e=0;for(let s=0;s<3;s++){const i=t[this.getElementIndex(g[s],m[s])];e+=2*i*i}return Math.sqrt(e)}eigenDecomposition(t){let e=0,s=0;t.unitary.identity(),t.diagonal.copy(this);const i=t.unitary,r=t.diagonal,n=Number.EPSILON*r.frobeniusNorm();for(;s<10&&r.offDiagonalFrobeniusNorm()>n;)r.shurDecomposition(y),x.copy(y).transpose(),r.multiply(y),r.premultiply(x),i.multiply(y),++e>2&&(s++,e=0);return t}shurDecomposition(t){let e=0,s=1;const i=this.elements;for(let t=0;t<3;t++){const r=Math.abs(i[this.getElementIndex(g[t],m[t])]);r>e&&(e=r,s=t)}let r=1,n=0;const o=m[s],h=g[s];if(Math.abs(i[this.getElementIndex(h,o)])>Number.EPSILON){const t=(i[this.getElementIndex(h,h)]-i[this.getElementIndex(o,o)])/2/i[this.getElementIndex(h,o)];let e;e=t<0?-1/(-t+Math.sqrt(1+t*t)):1/(t+Math.sqrt(1+t*t)),r=1/Math.sqrt(1+e*e),n=e*r}return t.identity(),t.elements[this.getElementIndex(o,o)]=r,t.elements[this.getElementIndex(h,h)]=r,t.elements[this.getElementIndex(h,o)]=n,t.elements[this.getElementIndex(o,h)]=-n,t}fromQuaternion(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=t.w,o=s+s,h=i+i,a=r+r,l=s*o,c=s*h,u=s*a,d=i*h,p=i*a,g=r*a,m=n*o,f=n*h,y=n*a;return e[0]=1-(d+g),e[3]=c-y,e[6]=u+f,e[1]=c+y,e[4]=1-(l+g),e[7]=p-m,e[2]=u-f,e[5]=p+m,e[8]=1-(l+d),this}fromMatrix4(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[4],e[4]=s[5],e[5]=s[6],e[6]=s[8],e[7]=s[9],e[8]=s[10],this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<9;i++)s[i]=t[i+e];return this}toArray(t,e=0){const s=this.elements;return t[e+0]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<9;t++)if(e[t]!==s[t])return!1;return!0}}const y=new f,x=new f,w=new f,S=new h;class v{constructor(t=0,e=0,s=0,i=1){this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}clone(){return(new this.constructor).copy(this)}inverse(){return this.conjugate().normalize()}conjugate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}length(){return Math.sqrt(this.squaredLength())}squaredLength(){return this.dot(this)}normalize(){let t=this.length();return 0===t?(this.x=0,this.y=0,this.z=0,this.w=1):(t=1/t,this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t.x,i=t.y,r=t.z,n=t.w,o=e.x,h=e.y,a=e.z,l=e.w;return this.x=s*l+n*o+i*a-r*h,this.y=i*l+n*h+r*o-s*a,this.z=r*l+n*a+s*h-i*o,this.w=n*l-s*o-i*h-r*a,this}angleTo(t){return 2*Math.acos(Math.abs(o.clamp(this.dot(t),-1,1)))}rotateTo(t,e,s=1e-4){const i=this.angleTo(t);if(i<s)return!0;const r=Math.min(1,e/i);return this.slerp(t,r),!1}lookAt(t,e,s){w.lookAt(t,e,s),this.fromMatrix3(w)}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const s=this.x,i=this.y,r=this.z,n=this.w;let o=n*t.w+s*t.x+i*t.y+r*t.z;if(o<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,o=-o):this.copy(t),o>=1)return this.w=n,this.x=s,this.y=i,this.z=r,this;const h=Math.sqrt(1-o*o);if(Math.abs(h)<.001)return this.w=.5*(n+this.w),this.x=.5*(s+this.x),this.y=.5*(i+this.y),this.z=.5*(r+this.z),this;const a=Math.atan2(h,o),l=Math.sin((1-e)*a)/h,c=Math.sin(e*a)/h;return this.w=n*l+this.w*c,this.x=s*l+this.x*c,this.y=i*l+this.y*c,this.z=r*l+this.z*c,this}extractRotationFromMatrix(t){const e=w.elements,s=t.elements,i=1/S.fromMatrix4Column(t,0).length(),r=1/S.fromMatrix4Column(t,1).length(),n=1/S.fromMatrix4Column(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=s[4]*r,e[4]=s[5]*r,e[5]=s[6]*r,e[6]=s[8]*n,e[7]=s[9]*n,e[8]=s[10]*n,this.fromMatrix3(w),this}fromEuler(t,e,s){const i=Math.cos(e/2),r=Math.cos(t/2),n=Math.cos(s/2),o=Math.sin(e/2),h=Math.sin(t/2),a=Math.sin(s/2);return this.w=i*r*n+o*h*a,this.x=i*h*n+o*r*a,this.y=o*r*n-i*h*a,this.z=i*r*a-o*h*n,this}toEuler(t){const e=-2*(this.y*this.z-this.x*this.w);return Math.abs(e)>.9999?(t.x=.5*Math.PI*e,t.y=Math.atan2(this.x*this.z+this.w*this.y,.5-this.x*this.x-this.y*this.y),t.z=0):(t.x=Math.asin(e),t.y=Math.atan2(this.x*this.z+this.w*this.y,.5-this.x*this.x-this.y*this.y),t.z=Math.atan2(this.x*this.y+this.w*this.z,.5-this.x*this.x-this.z*this.z)),t}fromMatrix3(t){const e=t.elements,s=e[0],i=e[3],r=e[6],n=e[1],o=e[4],h=e[7],a=e[2],l=e[5],c=e[8],u=s+o+c;if(u>0){let t=.5/Math.sqrt(u+1);this.w=.25/t,this.x=(l-h)*t,this.y=(r-a)*t,this.z=(n-i)*t}else if(s>o&&s>c){let t=2*Math.sqrt(1+s-o-c);this.w=(l-h)/t,this.x=.25*t,this.y=(i+n)/t,this.z=(r+a)/t}else if(o>c){let t=2*Math.sqrt(1+o-s-c);this.w=(r-a)/t,this.x=(i+n)/t,this.y=.25*t,this.z=(h+l)/t}else{let t=2*Math.sqrt(1+c-s-o);this.w=(n-i)/t,this.x=(r+a)/t,this.y=(h+l)/t,this.z=.25*t}return this}fromArray(t,e=0){return this.x=t[e+0],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t,e=0){return t[e+0]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}class b{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,s,i,r,n,o,h,a,l,c,u,d,p,g,m){const f=this.elements;return f[0]=t,f[4]=e,f[8]=s,f[12]=i,f[1]=r,f[5]=n,f[9]=o,f[13]=h,f[2]=a,f[6]=l,f[10]=c,f[14]=u,f[3]=d,f[7]=p,f[11]=g,f[15]=m,this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}clone(){return(new this.constructor).copy(this)}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[4],h=s[8],a=s[12],l=s[1],c=s[5],u=s[9],d=s[13],p=s[2],g=s[6],m=s[10],f=s[14],y=s[3],x=s[7],w=s[11],S=s[15],v=i[0],b=i[4],_=i[8],M=i[12],z=i[1],O=i[5],A=i[9],N=i[13],T=i[2],J=i[6],D=i[10],P=i[14],E=i[3],R=i[7],F=i[11],k=i[15];return r[0]=n*v+o*z+h*T+a*E,r[4]=n*b+o*O+h*J+a*R,r[8]=n*_+o*A+h*D+a*F,r[12]=n*M+o*N+h*P+a*k,r[1]=l*v+c*z+u*T+d*E,r[5]=l*b+c*O+u*J+d*R,r[9]=l*_+c*A+u*D+d*F,r[13]=l*M+c*N+u*P+d*k,r[2]=p*v+g*z+m*T+f*E,r[6]=p*b+g*O+m*J+f*R,r[10]=p*_+g*A+m*D+f*F,r[14]=p*M+g*N+m*P+f*k,r[3]=y*v+x*z+w*T+S*E,r[7]=y*b+x*O+w*J+S*R,r[11]=y*_+x*A+w*D+S*F,r[15]=y*M+x*N+w*P+S*k,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}extractBasis(t,e,s){return t.fromMatrix4Column(this,0),e.fromMatrix4Column(this,1),s.fromMatrix4Column(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}compose(t,e,s){return this.fromQuaternion(e),this.scale(s),this.setPosition(t),this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}setPosition(t){const e=this.elements;return e[12]=t.x,e[13]=t.y,e[14]=t.z,this}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}getInverse(t){const e=this.elements,s=t.elements,i=e[0],r=e[1],n=e[2],o=e[3],h=e[4],a=e[5],l=e[6],c=e[7],u=e[8],d=e[9],p=e[10],g=e[11],m=e[12],f=e[13],y=e[14],x=e[15],w=d*y*c-f*p*c+f*l*g-a*y*g-d*l*x+a*p*x,S=m*p*c-u*y*c-m*l*g+h*y*g+u*l*x-h*p*x,v=u*f*c-m*d*c+m*a*g-h*f*g-u*a*x+h*d*x,b=m*d*l-u*f*l-m*a*p+h*f*p+u*a*y-h*d*y,_=i*w+r*S+n*v+o*b;if(0===_)return t.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/_;return s[0]=w*M,s[1]=(f*p*o-d*y*o-f*n*g+r*y*g+d*n*x-r*p*x)*M,s[2]=(a*y*o-f*l*o+f*n*c-r*y*c-a*n*x+r*l*x)*M,s[3]=(d*l*o-a*p*o-d*n*c+r*p*c+a*n*g-r*l*g)*M,s[4]=S*M,s[5]=(u*y*o-m*p*o+m*n*g-i*y*g-u*n*x+i*p*x)*M,s[6]=(m*l*o-h*y*o-m*n*c+i*y*c+h*n*x-i*l*x)*M,s[7]=(h*p*o-u*l*o+u*n*c-i*p*c-h*n*g+i*l*g)*M,s[8]=v*M,s[9]=(m*d*o-u*f*o-m*r*g+i*f*g+u*r*x-i*d*x)*M,s[10]=(h*f*o-m*a*o+m*r*c-i*f*c-h*r*x+i*a*x)*M,s[11]=(u*a*o-h*d*o-u*r*c+i*d*c+h*r*g-i*a*g)*M,s[12]=b*M,s[13]=(u*f*n-m*d*n+m*r*p-i*f*p-u*r*y+i*d*y)*M,s[14]=(m*a*n-h*f*n-m*r*l+i*f*l+h*r*y-i*a*y)*M,s[15]=(h*d*n-u*a*n+u*r*l-i*d*l-h*r*p+i*a*p)*M,t}getMaxScale(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}fromQuaternion(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=t.w,o=s+s,h=i+i,a=r+r,l=s*o,c=s*h,u=s*a,d=i*h,p=i*a,g=r*a,m=n*o,f=n*h,y=n*a;return e[0]=1-(d+g),e[4]=c-y,e[8]=u+f,e[1]=c+y,e[5]=1-(l+g),e[9]=p-m,e[2]=u-f,e[6]=p+m,e[10]=1-(l+d),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}fromMatrix3(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=0,e[4]=s[3],e[5]=s[4],e[6]=s[5],e[7]=0,e[8]=s[6],e[9]=s[7],e[10]=s[8],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<16;i++)s[i]=t[i+e];return this}toArray(t,e=0){const s=this.elements;return t[e+0]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<16;t++)if(e[t]!==s[t])return!1;return!0}}const _=new v,M=new h,z=new h,O=new v;class A{constructor(){this.name="",this.active=!0,this.children=new Array,this.parent=null,this.neighbors=new Array,this.neighborhoodRadius=1,this.updateNeighborhood=!1,this.position=new h,this.rotation=new v,this.scale=new h(1,1,1),this.forward=new h(0,0,1),this.up=new h(0,1,0),this.boundingRadius=0,this.maxTurnRate=Math.PI,this.canActivateTrigger=!0,this.manager=null,this._localMatrix=new b,this._worldMatrix=new b,this._cache={position:new h,rotation:new v,scale:new h(1,1,1)},this._renderComponent=null,this._renderComponentCallback=null,this._started=!1,this._uuid=null,this._worldMatrixDirty=!1}get worldMatrix(){return this._updateWorldMatrix(),this._worldMatrix}get uuid(){return null===this._uuid&&(this._uuid=o.generateUUID()),this._uuid}start(){return this}update(){return this}add(t){return null!==t.parent&&t.parent.remove(t),this.children.push(t),t.parent=this,this}remove(t){const e=this.children.indexOf(t);return this.children.splice(e,1),t.parent=null,this}getDirection(t){return t.copy(this.forward).applyRotation(this.rotation).normalize()}lookAt(t){const e=this.parent;return null!==e?(this.getWorldPosition(z),M.subVectors(t,z).normalize(),this.rotation.lookAt(this.forward,M,this.up),O.extractRotationFromMatrix(e.worldMatrix).inverse(),this.rotation.premultiply(O)):(M.subVectors(t,this.position).normalize(),this.rotation.lookAt(this.forward,M,this.up)),this}rotateTo(t,e,s=1e-4){const i=this.parent;return null!==i?(this.getWorldPosition(z),M.subVectors(t,z).normalize(),_.lookAt(this.forward,M,this.up),O.extractRotationFromMatrix(i.worldMatrix).inverse(),_.premultiply(O)):(M.subVectors(t,this.position).normalize(),_.lookAt(this.forward,M,this.up)),this.rotation.rotateTo(_,this.maxTurnRate*e,s)}getWorldDirection(t){return O.extractRotationFromMatrix(this.worldMatrix),t.copy(this.forward).applyRotation(O).normalize()}getWorldPosition(t){return t.extractPositionFromMatrix(this.worldMatrix)}setRenderComponent(t,e){return this._renderComponent=t,this._renderComponentCallback=e,this}handleMessage(){return!1}lineOfSightTest(){return null}sendMessage(t,e,i=0,r=null){return null!==this.manager?this.manager.sendMessage(this,t,e,i,r):s.error("YUKA.GameEntity: The game entity must be added to a manager in order to send a message."),this}toJSON(){return{type:this.constructor.name,uuid:this.uuid,name:this.name,active:this.active,children:N(this.children),parent:null!==this.parent?this.parent.uuid:null,neighbors:N(this.neighbors),neighborhoodRadius:this.neighborhoodRadius,updateNeighborhood:this.updateNeighborhood,position:this.position.toArray(new Array),rotation:this.rotation.toArray(new Array),scale:this.scale.toArray(new Array),forward:this.forward.toArray(new Array),up:this.up.toArray(new Array),boundingRadius:this.boundingRadius,maxTurnRate:this.maxTurnRate,canActivateTrigger:this.canActivateTrigger,worldMatrix:this.worldMatrix.toArray(new Array),_localMatrix:this._localMatrix.toArray(new Array),_cache:{position:this._cache.position.toArray(new Array),rotation:this._cache.rotation.toArray(new Array),scale:this._cache.scale.toArray(new Array)},_started:this._started}}fromJSON(t){return this.name=t.name,this.active=t.active,this.neighborhoodRadius=t.neighborhoodRadius,this.updateNeighborhood=t.updateNeighborhood,this.position.fromArray(t.position),this.rotation.fromArray(t.rotation),this.scale.fromArray(t.scale),this.forward.fromArray(t.forward),this.up.fromArray(t.up),this.boundingRadius=t.boundingRadius,this.maxTurnRate=t.maxTurnRate,this.canActivateTrigger=t.canActivateTrigger,this.children=t.children.slice(),this.neighbors=t.neighbors.slice(),this.parent=t.parent,this._localMatrix.fromArray(t._localMatrix),this._worldMatrix.fromArray(t.worldMatrix),this._cache.position.fromArray(t._cache.position),this._cache.rotation.fromArray(t._cache.rotation),this._cache.scale.fromArray(t._cache.scale),this._started=t._started,this._uuid=t.uuid,this}resolveReferences(t){const e=this.neighbors;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s]);const s=this.children;for(let e=0,i=s.length;e<i;e++)s[e]=t.get(s[e]);return this.parent=t.get(this.parent)||null,this}_updateMatrix(){const t=this._cache;t.position.equals(this.position)&&t.rotation.equals(this.rotation)&&t.scale.equals(this.scale)||(this._localMatrix.compose(this.position,this.rotation,this.scale),t.position.copy(this.position),t.rotation.copy(this.rotation),t.scale.copy(this.scale),this._worldMatrixDirty=!0)}_updateWorldMatrix(){const t=this.parent;if(null!==t&&t._updateWorldMatrix(),this._updateMatrix(),!0===this._worldMatrixDirty){null===t?this._worldMatrix.copy(this._localMatrix):this._worldMatrix.multiplyMatrices(this.parent._worldMatrix,this._localMatrix),this._worldMatrixDirty=!1;const e=this.children;for(let t=0,s=e.length;t<s;t++){e[t]._worldMatrixDirty=!0}}}updateWorldMatrix(){return console.warn("GameEntity: .updateWorldMatrix() has been removed. World matrices are automatically updated on access."),this}}function N(t){const e=new Array;for(let s=0,i=t.length;s<i;s++)e.push(t[s].uuid);return e}const T=new h,J=new h;class D extends A{constructor(){super(),this.velocity=new h,this.maxSpeed=1,this.updateOrientation=!0}update(t){return this.getSpeedSquared()>this.maxSpeed*this.maxSpeed&&(this.velocity.normalize(),this.velocity.multiplyScalar(this.maxSpeed)),T.copy(this.velocity).multiplyScalar(t),J.copy(this.position).add(T),this.updateOrientation&&this.getSpeedSquared()>1e-8&&this.lookAt(J),this.position.copy(J),this}getSpeed(){return this.velocity.length()}getSpeedSquared(){return this.velocity.squaredLength()}toJSON(){const t=super.toJSON();return t.velocity=this.velocity.toArray(new Array),t.maxSpeed=this.maxSpeed,t.updateOrientation=this.updateOrientation,t}fromJSON(t){return super.fromJSON(t),this.velocity.fromArray(t.velocity),this.maxSpeed=t.maxSpeed,this.updateOrientation=t.updateOrientation,this}}class P{constructor(){this.active=!0,this.weight=1}calculate(){}toJSON(){return{type:this.constructor.name,active:this.active,weight:this.weight}}fromJSON(t){return this.active=t.active,this.weight=t.weight,this}resolveReferences(){}}const E=new h,R=new h;class F extends P{constructor(){super()}calculate(t,e){E.set(0,0,0);const s=t.neighbors;for(let t=0,e=s.length;t<e;t++){s[t].getDirection(R),E.add(R)}return s.length>0&&(E.divideScalar(s.length),t.getDirection(R),e.subVectors(E,R)),e}}const k=new h,V=new h;class C extends P{constructor(t=new h,e=3,s=0){super(),this.target=t,this.deceleration=e,this.tolerance=s}calculate(t,e){const s=this.target,i=this.deceleration;V.subVectors(s,t.position);const r=V.length();if(r>this.tolerance){let e=r/i;e=Math.min(e,t.maxSpeed),k.copy(V).multiplyScalar(e/r)}else k.set(0,0,0);return e.subVectors(k,t.velocity)}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t.deceleration=this.deceleration,t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this.deceleration=t.deceleration,this}}const B=new h;class q extends P{constructor(t=new h){super(),this.target=t}calculate(t,e){const s=this.target;return B.subVectors(s,t.position).normalize(),B.multiplyScalar(t.maxSpeed),e.subVectors(B,t.velocity)}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this}}const I=new h;class U extends P{constructor(){super(),this._seek=new q}calculate(t,e){I.set(0,0,0);const s=t.neighbors;for(let t=0,e=s.length;t<e;t++){const e=s[t];I.add(e.position)}return s.length>0&&(I.divideScalar(s.length),this._seek.target=I,this._seek.calculate(t,e),e.normalize()),e}}const L=new h;class Y extends P{constructor(t=new h,e=10){super(),this.target=t,this.panicDistance=e}calculate(t,e){const s=this.target;return t.position.squaredDistanceTo(s)<=this.panicDistance*this.panicDistance&&(L.subVectors(t.position,s).normalize(),0===L.squaredLength()&&L.set(0,0,1),L.multiplyScalar(t.maxSpeed),e.subVectors(L,t.velocity)),e}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t.panicDistance=this.panicDistance,t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this.panicDistance=t.panicDistance,this}}const H=new h,W=new h,j=new h;class K extends P{constructor(t=null,e=10,s=1){super(),this.pursuer=t,this.panicDistance=e,this.predictionFactor=s,this._flee=new Y}calculate(t,e){const s=this.pursuer;H.subVectors(s.position,t.position);let i=H.length()/(t.maxSpeed+s.getSpeed());return i*=this.predictionFactor,W.copy(s.velocity).multiplyScalar(i),j.addVectors(s.position,W),this._flee.target=j,this._flee.panicDistance=this.panicDistance,this._flee.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.pursuer=this.pursuer?this.pursuer.uuid:null,t.panicDistance=this.panicDistance,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.pursuer=t.pursuer,this.panicDistance=t.panicDistance,this.predictionFactor=t.predictionFactor,this}resolveReferences(t){this.pursuer=t.get(this.pursuer)||null}}class G{constructor(){this.loop=!1,this._waypoints=new Array,this._index=0}add(t){return this._waypoints.push(t),this}clear(){return this._waypoints.length=0,this._index=0,this}current(){return this._waypoints[this._index]}finished(){const t=this._waypoints.length-1;return!0!==this.loop&&this._index===t}advance(){return this._index++,this._index===this._waypoints.length&&(!0===this.loop?this._index=0:this._index--),this}toJSON(){const t={type:this.constructor.name,loop:this.loop,_waypoints:new Array,_index:this._index},e=this._waypoints;for(let s=0,i=e.length;s<i;s++){const i=e[s];t._waypoints.push(i.toArray(new Array))}return t}fromJSON(t){this.loop=t.loop,this._index=t._index;const e=t._waypoints;for(let t=0,s=e.length;t<s;t++){const s=e[t];this._waypoints.push((new h).fromArray(s))}return this}}class Z extends P{constructor(t=new G,e=1){super(),this.path=t,this.nextWaypointDistance=e,this._arrive=new C,this._seek=new q}calculate(t,e){const s=this.path;s.current().squaredDistanceTo(t.position)<this.nextWaypointDistance*this.nextWaypointDistance&&s.advance();const i=s.current();return!0===s.finished()?(this._arrive.target=i,this._arrive.calculate(t,e)):(this._seek.target=i,this._seek.calculate(t,e)),e}toJSON(){const t=super.toJSON();return t.path=this.path.toJSON(),t.nextWaypointDistance=this.nextWaypointDistance,t}fromJSON(t){return super.fromJSON(t),this.path.fromJSON(t.path),this.nextWaypointDistance=t.nextWaypointDistance,this}}const X=new h,Q=new h,$=new h,tt=new h;class et extends P{constructor(t=null,e=null,s=3){super(),this.entity1=t,this.entity2=e,this.deceleration=s,this._arrive=new C}calculate(t,e){const s=this.entity1,i=this.entity2;X.addVectors(s.position,i.position).multiplyScalar(.5);const r=t.position.distanceTo(X)/t.maxSpeed;return Q.copy(s.velocity).multiplyScalar(r),$.addVectors(s.position,Q),Q.copy(i.velocity).multiplyScalar(r),tt.addVectors(i.position,Q),X.addVectors($,tt).multiplyScalar(.5),this._arrive.deceleration=this.deceleration,this._arrive.target=X,this._arrive.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.entity1=this.entity1?this.entity1.uuid:null,t.entity2=this.entity2?this.entity2.uuid:null,t.deceleration=this.deceleration,t}fromJSON(t){return super.fromJSON(t),this.entity1=t.entity1,this.entity2=t.entity2,this.deceleration=t.deceleration,this}resolveReferences(t){this.entity1=t.get(this.entity1)||null,this.entity2=t.get(this.entity2)||null}}const st=new h,it=new h,rt=new h,nt=[new h,new h,new h,new h,new h,new h,new h,new h];class ot{constructor(t=new h,e=new h){this.min=t,this.max=e}set(t,e){return this.min=t,this.max=e,this}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}clone(){return(new this.constructor).copy(this)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max),e}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}expand(t){return this.min.min(t),this.max.max(t),this}getCenter(t){return t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t.subVectors(this.max,this.min)}intersectsAABB(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsBoundingSphere(t){return this.clampPoint(t.center,st),st.squaredDistanceTo(t.center)<=t.radius*t.radius}intersectsPlane(t){const e=t.normal;this.getCenter(it),rt.subVectors(this.max,it);const s=rt.x*Math.abs(e.x)+rt.y*Math.abs(e.y)+rt.z*Math.abs(e.z),i=t.distanceToPoint(it);return Math.abs(i)<=s}getNormalFromSurfacePoint(t,e){let s;e.set(0,0,0);let i=1/0;return this.getCenter(it),this.getSize(rt),st.copy(t).sub(it),s=Math.abs(rt.x-Math.abs(st.x)),s<i&&(i=s,e.set(1*Math.sign(st.x),0,0)),s=Math.abs(rt.y-Math.abs(st.y)),s<i&&(i=s,e.set(0,1*Math.sign(st.y),0)),s=Math.abs(rt.z-Math.abs(st.z)),s<i&&e.set(0,0,1*Math.sign(st.z)),e}fromCenterAndSize(t,e){return st.copy(e).multiplyScalar(.5),this.min.copy(t).sub(st),this.max.copy(t).add(st),this}fromPoints(t){this.min.set(1/0,1/0,1/0),this.max.set(-1/0,-1/0,-1/0);for(let e=0,s=t.length;e<s;e++)this.expand(t[e]);return this}applyMatrix4(t){const e=this.min,s=this.max;return nt[0].set(e.x,e.y,e.z).applyMatrix4(t),nt[1].set(e.x,e.y,s.z).applyMatrix4(t),nt[2].set(e.x,s.y,e.z).applyMatrix4(t),nt[3].set(e.x,s.y,s.z).applyMatrix4(t),nt[4].set(s.x,e.y,e.z).applyMatrix4(t),nt[5].set(s.x,e.y,s.z).applyMatrix4(t),nt[6].set(s.x,s.y,e.z).applyMatrix4(t),nt[7].set(s.x,s.y,s.z).applyMatrix4(t),this.fromPoints(nt)}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{type:this.constructor.name,min:this.min.toArray(new Array),max:this.max.toArray(new Array)}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const ht=new ot;class at{constructor(t=new h,e=0){this.center=t,this.radius=e}set(t,e){return this.center=t,this.radius=e,this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}clone(){return(new this.constructor).copy(this)}clampPoint(t,e){e.copy(t);return this.center.squaredDistanceTo(t)>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}containsPoint(t){return t.squaredDistanceTo(this.center)<=this.radius*this.radius}intersectsBoundingSphere(t){const e=this.radius+t.radius;return t.center.squaredDistanceTo(this.center)<=e*e}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}getNormalFromSurfacePoint(t,e){return e.subVectors(t,this.center).normalize()}fromPoints(t){return ht.fromPoints(t),ht.getCenter(this.center),this.radius=this.center.distanceTo(ht.max),this}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScale(),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}toJSON(){return{type:this.constructor.name,center:this.center.toArray(new Array),radius:this.radius}}fromJSON(t){return this.center.fromArray(t.center),this.radius=t.radius,this}}const lt=new h,ct=new h,ut=new h,dt=new h,pt=new h,gt=new b,mt=new b,ft=new ot;class yt{constructor(t=new h,e=new h){this.origin=t,this.direction=e}set(t,e){return this.origin=t,this.direction=e,this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}clone(){return(new this.constructor).copy(this)}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}intersectBoundingSphere(t,e){lt.subVectors(t.center,this.origin);const s=lt.dot(this.direction),i=lt.dot(lt)-s*s,r=t.radius*t.radius;if(i>r)return null;const n=Math.sqrt(r-i),o=s-n,h=s+n;return o<0&&h<0?null:o<0?this.at(h,e):this.at(o,e)}intersectsBoundingSphere(t){const e=new h;let s;const i=e.subVectors(t.center,this.origin).dot(this.direction);return i<0?s=this.origin.squaredDistanceTo(t.center):(e.copy(this.direction).multiplyScalar(i).add(this.origin),s=e.squaredDistanceTo(t.center)),s<=t.radius*t.radius}intersectAABB(t,e){let s,i,r,n,o,h;const a=1/this.direction.x,l=1/this.direction.y,c=1/this.direction.z,u=this.origin;return a>=0?(s=(t.min.x-u.x)*a,i=(t.max.x-u.x)*a):(s=(t.max.x-u.x)*a,i=(t.min.x-u.x)*a),l>=0?(r=(t.min.y-u.y)*l,n=(t.max.y-u.y)*l):(r=(t.max.y-u.y)*l,n=(t.min.y-u.y)*l),s>n||r>i?null:((r>s||s!=s)&&(s=r),(n<i||i!=i)&&(i=n),c>=0?(o=(t.min.z-u.z)*c,h=(t.max.z-u.z)*c):(o=(t.max.z-u.z)*c,h=(t.min.z-u.z)*c),s>h||o>i?null:((o>s||s!=s)&&(s=o),(h<i||i!=i)&&(i=h),i<0?null:this.at(s>=0?s:i,e)))}intersectsAABB(t){return null!==this.intersectAABB(t,lt)}intersectPlane(t,e){let s;const i=t.normal.dot(this.direction);if(0===i){if(0!==t.distanceToPoint(this.origin))return null;s=0}else s=-(this.origin.dot(t.normal)+t.constant)/i;return s>=0?this.at(s,e):null}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectOBB(t,e){return t.getSize(pt),ft.fromCenterAndSize(lt.set(0,0,0),pt),gt.fromMatrix3(t.rotation),gt.setPosition(t.center),xt.copy(this).applyMatrix4(gt.getInverse(mt)),xt.intersectAABB(ft,e)?e.applyMatrix4(gt):null}intersectsOBB(t){return null!==this.intersectOBB(t,lt)}intersectConvexHull(t,e){const s=t.faces;let i=-1/0,r=1/0;for(let t=0,e=s.length;t<e;t++){const e=s[t].plane,n=e.distanceToPoint(this.origin),o=e.normal.dot(this.direction);if(n>0&&o>=0)return null;const h=0!==o?-n/o:0;if(!(h<=0)&&(o>0?r=Math.min(h,r):i=Math.max(h,i),i>r))return null}return i!==-1/0?this.at(i,e):this.at(r,e),e}intersectsConvexHull(t){return null!==this.intersectConvexHull(t,lt)}intersectTriangle(t,e,s){const i=t.a,r=t.b,n=t.c;ct.subVectors(r,i),ut.subVectors(n,i),dt.crossVectors(ct,ut);let o,h=this.direction.dot(dt);if(h>0){if(e)return null;o=1}else{if(!(h<0))return null;o=-1,h=-h}lt.subVectors(this.origin,i);const a=o*this.direction.dot(ut.crossVectors(lt,ut));if(a<0)return null;const l=o*this.direction.dot(ct.cross(lt));if(l<0)return null;if(a+l>h)return null;const c=-o*lt.dot(dt);return c<0?null:this.at(c/h,s)}intersectBVH(t,e){return t.root.intersectRay(this,e)}intersectsBVH(t){return t.root.intersectsRay(this)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}const xt=new yt,wt=new b,St=new h,vt=new h,bt=new h,_t=new at,Mt=new yt(new h(0,0,0),new h(0,0,1));class zt extends P{constructor(t=new Array){super(),this.obstacles=t,this.brakingWeight=.2,this.dBoxMinLength=4}calculate(t,e){const s=this.obstacles;let i=null,r=1/0;const n=this.dBoxMinLength+t.getSpeed()/t.maxSpeed*this.dBoxMinLength;t.worldMatrix.getInverse(wt);for(let e=0,o=s.length;e<o;e++){const o=s[e];if(o!==t&&(St.copy(o.position).applyMatrix4(wt),St.z>0&&Math.abs(St.z)<n)){const e=o.boundingRadius+t.boundingRadius;Math.abs(St.x)<e&&(_t.center.copy(St),_t.radius=e,Mt.intersectBoundingSphere(_t,bt),bt.z<r&&(r=bt.z,i=o,vt.copy(St)))}}if(null!==i){const s=1+(n-vt.z)/n;e.x=(i.boundingRadius-vt.x)*s,e.z=(i.boundingRadius-vt.z)*this.brakingWeight,e.applyRotation(t.rotation)}return e}toJSON(){const t=super.toJSON();t.obstacles=new Array,t.brakingWeight=this.brakingWeight,t.dBoxMinLength=this.dBoxMinLength;for(let e=0,s=this.obstacles.length;e<s;e++)t.obstacles.push(this.obstacles[e].uuid);return t}fromJSON(t){return super.fromJSON(t),this.obstacles=t.obstacles,this.brakingWeight=t.brakingWeight,this.dBoxMinLength=t.dBoxMinLength,this}resolveReferences(t){const e=this.obstacles;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s])}}const Ot=new h,At=new h,Nt=new h,Tt=new h;class Jt extends P{constructor(t=null,e=new h){super(),this.leader=t,this.offset=e,this._arrive=new C,this._arrive.deceleration=1.5}calculate(t,e){const s=this.leader,i=this.offset;Ot.copy(i).applyMatrix4(s.worldMatrix),At.subVectors(Ot,t.position);const r=At.length()/(t.maxSpeed+s.getSpeed());return Nt.copy(s.velocity).multiplyScalar(r),Tt.addVectors(Ot,Nt),this._arrive.target=Tt,this._arrive.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.leader=this.leader?this.leader.uuid:null,t.offset=this.offset,t}fromJSON(t){return super.fromJSON(t),this.leader=t.leader,this.offset=t.offset,this}resolveReferences(t){this.leader=t.get(this.leader)||null}}const Dt=new h,Pt=new h,Et=new h,Rt=new h,Ft=new h;class kt extends P{constructor(t=null,e=1){super(),this.evader=t,this.predictionFactor=e,this._seek=new q}calculate(t,e){const s=this.evader;Dt.subVectors(s.position,t.position),t.getDirection(Pt),s.getDirection(Et);const i=Dt.dot(Pt)>0,r=Pt.dot(Et)<-.95;if(!0===i&&!0===r)return this._seek.target=s.position,this._seek.calculate(t,e),e;let n=Dt.length()/(t.maxSpeed+s.getSpeed());return n*=this.predictionFactor,Rt.copy(s.velocity).multiplyScalar(n),Ft.addVectors(s.position,Rt),this._seek.target=Ft,this._seek.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.evader=this.evader?this.evader.uuid:null,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.evader=t.evader,this.predictionFactor=t.predictionFactor,this}resolveReferences(t){this.evader=t.get(this.evader)||null}}const Vt=new h;class Ct extends P{constructor(){super()}calculate(t,e){const s=t.neighbors;for(let i=0,r=s.length;i<r;i++){const r=s[i];Vt.subVectors(t.position,r.position);let n=Vt.length();0===n&&(n=1e-4),Vt.normalize().divideScalar(n),e.add(Vt)}return e}}const Bt=new h,qt=new h;class It extends P{constructor(t=1,e=5,s=5){super(),this.radius=t,this.distance=e,this.jitter=s,this._targetLocal=new h,function(t,e){const s=Math.random()*Math.PI*2;e.x=t*Math.cos(s),e.z=t*Math.sin(s)}(this.radius,this._targetLocal)}calculate(t,e,s){const i=this.jitter*s;return qt.x=o.randFloat(-1,1)*i,qt.z=o.randFloat(-1,1)*i,this._targetLocal.add(qt),this._targetLocal.normalize(),this._targetLocal.multiplyScalar(this.radius),Bt.copy(this._targetLocal),Bt.z+=this.distance,Bt.applyMatrix4(t.worldMatrix),e.subVectors(Bt,t.position),e}toJSON(){const t=super.toJSON();return t.radius=this.radius,t.distance=this.distance,t.jitter=this.jitter,t._targetLocal=this._targetLocal.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.radius=t.radius,this.distance=t.distance,this.jitter=t.jitter,this._targetLocal.fromArray(t._targetLocal),this}}const Ut=new h;class Lt{constructor(t){this.vehicle=t,this.behaviors=new Array,this._steeringForce=new h,this._typesMap=new Map}add(t){return this.behaviors.push(t),this}remove(t){const e=this.behaviors.indexOf(t);return this.behaviors.splice(e,1),this}clear(){return this.behaviors.length=0,this}calculate(t,e){return this._calculateByOrder(t),e.copy(this._steeringForce)}_accumulate(t){const e=this._steeringForce.length(),s=this.vehicle.maxForce-e;if(s<=0)return!1;return t.length()>s&&t.normalize().multiplyScalar(s),this._steeringForce.add(t),!0}_calculateByOrder(t){const e=this.behaviors;this._steeringForce.set(0,0,0);for(let s=0,i=e.length;s<i;s++){const i=e[s];if(!0===i.active&&(Ut.set(0,0,0),i.calculate(this.vehicle,Ut,t),Ut.multiplyScalar(i.weight),!1===this._accumulate(Ut)))return}}toJSON(){const t={type:"SteeringManager",behaviors:new Array},e=this.behaviors;for(let s=0,i=e.length;s<i;s++){const i=e[s];t.behaviors.push(i.toJSON())}return t}fromJSON(t){this.clear();const e=t.behaviors;for(let t=0,i=e.length;t<i;t++){const i=e[t],r=i.type;let n;switch(r){case"SteeringBehavior":n=(new P).fromJSON(i);break;case"AlignmentBehavior":n=(new F).fromJSON(i);break;case"ArriveBehavior":n=(new C).fromJSON(i);break;case"CohesionBehavior":n=(new U).fromJSON(i);break;case"EvadeBehavior":n=(new K).fromJSON(i);break;case"FleeBehavior":n=(new Y).fromJSON(i);break;case"FollowPathBehavior":n=(new Z).fromJSON(i);break;case"InterposeBehavior":n=(new et).fromJSON(i);break;case"ObstacleAvoidanceBehavior":n=(new zt).fromJSON(i);break;case"OffsetPursuitBehavior":n=(new Jt).fromJSON(i);break;case"PursuitBehavior":n=(new kt).fromJSON(i);break;case"SeekBehavior":n=(new q).fromJSON(i);break;case"SeparationBehavior":n=(new Ct).fromJSON(i);break;case"WanderBehavior":n=(new It).fromJSON(i);break;default:const t=this._typesMap.get(r);if(void 0===t){s.warn("YUKA.SteeringManager: Unsupported steering behavior type:",r);continue}n=(new t).fromJSON(i)}this.add(n)}return this}registerType(t,e){return this._typesMap.set(t,e),this}resolveReferences(t){const e=this.behaviors;for(let s=0,i=e.length;s<i;s++){e[s].resolveReferences(t)}return this}}class Yt{constructor(t=10){this.count=t,this._history=new Array,this._slot=0;for(let t=0;t<this.count;t++)this._history[t]=new h}calculate(t,e){e.set(0,0,0),this._slot===this.count&&(this._slot=0),this._history[this._slot].copy(t),this._slot++;for(let t=0;t<this.count;t++)e.add(this._history[t]);return e.divideScalar(this.count),e}toJSON(){const t={type:this.constructor.name,count:this.count,_history:new Array,_slot:this._slot},e=this._history;for(let s=0,i=e.length;s<i;s++){const i=e[s];t._history.push(i.toArray(new Array))}return t}fromJSON(t){this.count=t.count,this._slot=t._slot;const e=t._history;this._history.length=0;for(let t=0,s=e.length;t<s;t++){const s=e[t];this._history.push((new h).fromArray(s))}return this}}const Ht=new h,Wt=new h,jt=new h,Kt=new h,Gt=new h;class Zt extends D{constructor(){super(),this.mass=1,this.maxForce=100,this.steering=new Lt(this),this.smoother=null}update(t){return this.steering.calculate(t,Ht),jt.copy(Ht).divideScalar(this.mass),this.velocity.add(jt.multiplyScalar(t)),this.getSpeedSquared()>this.maxSpeed*this.maxSpeed&&(this.velocity.normalize(),this.velocity.multiplyScalar(this.maxSpeed)),Wt.copy(this.velocity).multiplyScalar(t),Kt.copy(this.position).add(Wt),!0===this.updateOrientation&&null===this.smoother&&this.getSpeedSquared()>1e-8&&this.lookAt(Kt),this.position.copy(Kt),!0===this.updateOrientation&&null!==this.smoother&&(this.smoother.calculate(this.velocity,Gt),Wt.copy(Gt).multiplyScalar(t),Kt.copy(this.position).add(Wt),this.lookAt(Kt)),this}toJSON(){const t=super.toJSON();return t.mass=this.mass,t.maxForce=this.maxForce,t.steering=this.steering.toJSON(),t.smoother=this.smoother?this.smoother.toJSON():null,t}fromJSON(t){return super.fromJSON(t),this.mass=t.mass,this.maxForce=t.maxForce,this.steering=new Lt(this).fromJSON(t.steering),this.smoother=t.smoother?(new Yt).fromJSON(t.smoother):null,this}resolveReferences(t){super.resolveReferences(t),this.steering.resolveReferences(t)}}class Xt{touching(){return!1}update(){return this}toJSON(){return{type:this.constructor.name}}fromJSON(){return this}}const Qt=new at,$t=new h;class te extends Xt{constructor(t=new h){super(),this.size=t,this._aabb=new ot}touching(t){return Qt.set(t.position,t.boundingRadius),this._aabb.intersectsBoundingSphere(Qt)}update(t){return t.getWorldPosition($t),this._aabb.fromCenterAndSize($t,this.size),this}toJSON(){const t=super.toJSON();return t.size=this.size.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.size.fromArray(t.size),this}}const ee=new at;class se extends Xt{constructor(t=0){super(),this.radius=t,this._boundingSphere=new at}touching(t){return t.getWorldPosition(ee.center),ee.radius=t.boundingRadius,this._boundingSphere.intersectsBoundingSphere(ee)}update(t){return t.getWorldPosition(this._boundingSphere.center),this._boundingSphere.radius=this.radius,this}toJSON(){const t=super.toJSON();return t.radius=this.radius,t}fromJSON(t){return super.fromJSON(t),this.radius=t.radius,this}}class ie extends A{constructor(t=new Xt){super(),this.region=t,this.canActivateTrigger=!1,this._typesMap=new Map}check(t){return!0===this.region.touching(t)&&this.execute(t),this}execute(){}updateRegion(){return this.region.update(this),this}toJSON(){const t=super.toJSON();return t.region=this.region.toJSON(),t}fromJSON(t){super.fromJSON(t);const e=t.region;let i=e.type;switch(i){case"TriggerRegion":this.region=(new Xt).fromJSON(e);break;case"RectangularTriggerRegion":this.region=(new te).fromJSON(e);break;case"SphericalTriggerRegion":this.region=(new se).fromJSON(e);break;default:const t=this._typesMap.get(i);void 0!==t?this.region=(new t).fromJSON(e):s.warn("YUKA.Trigger: Unsupported trigger region type:",e.type)}return this}registerType(t,e){return this._typesMap.set(t,e),this}}const re=new Array;const ne=new h,oe=new h,he=new h;class ae{constructor(t=new h(0,0,1),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal=t,this.constant=e,this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}clone(){return(new this.constructor).copy(this)}distanceToPoint(t){return this.normal.dot(t)+this.constant}fromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}fromCoplanarPoints(t,e,s){return ne.subVectors(s,e).cross(oe.subVectors(t,e)).normalize(),this.fromNormalAndCoplanarPoint(ne,t),this}intersectPlane(t,e){he.crossVectors(this.normal,t.normal);const s=he.dot(he);return 0===s?null:(ne.copy(t.normal).multiplyScalar(this.constant),oe.copy(this.normal).multiplyScalar(t.constant),e.crossVectors(ne.sub(oe),he).divideScalar(s),e)}intersectsPlane(t){const e=this.normal.dot(t.normal);return 1!==Math.abs(e)}projectPoint(t,e){return ne.copy(this.normal).multiplyScalar(this.distanceToPoint(t)),e.subVectors(t,ne),e}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const le=new at,ce={a:new h,b:new h,c:new h},ue=new yt,de=new ae,pe=new b,ge=new h,me={a:new h,b:new h,c:new h};class fe{constructor(t=new Float32Array,e=null){this.vertices=t,this.indices=e,this.backfaceCulling=!0,this.aabb=new ot,this.boundingSphere=new at,this.computeBoundingVolume()}computeBoundingVolume(){const t=this.vertices,e=new h,s=this.aabb,i=this.boundingSphere;s.min.set(1/0,1/0,1/0),s.max.set(-1/0,-1/0,-1/0);for(let i=0,r=t.length;i<r;i+=3)e.x=t[i],e.y=t[i+1],e.z=t[i+2],s.expand(e);return s.getCenter(i.center),i.radius=i.center.distanceTo(s.max),this}intersectRay(t,e,s,i,r=null){if(le.copy(this.boundingSphere).applyMatrix4(e),t.intersectsBoundingSphere(le)&&(e.getInverse(pe),ue.copy(t).applyMatrix4(pe),ue.intersectsAABB(this.aabb))){const t=this.vertices,n=this.indices;let o=1/0,h=!1;if(null===n){for(let e=0,r=t.length;e<r;e+=9)if(ce.a.set(t[e],t[e+1],t[e+2]),ce.b.set(t[e+3],t[e+4],t[e+5]),ce.c.set(t[e+6],t[e+7],t[e+8]),null!==ue.intersectTriangle(ce,this.backfaceCulling,i)){if(!s){h=!0;break}{const t=i.squaredDistanceTo(ue.origin);t<o&&(o=t,ge.copy(i),me.a.copy(ce.a),me.b.copy(ce.b),me.c.copy(ce.c),h=!0)}}}else for(let e=0,r=n.length;e<r;e+=3){const r=n[e],a=n[e+1],l=n[e+2],c=3;if(ce.a.set(t[r*c],t[r*c+1],t[r*c+2]),ce.b.set(t[a*c],t[a*c+1],t[a*c+2]),ce.c.set(t[l*c],t[l*c+1],t[l*c+2]),null!==ue.intersectTriangle(ce,this.backfaceCulling,i)){if(!s){h=!0;break}{const t=i.squaredDistanceTo(ue.origin);t<o&&(o=t,ge.copy(i),me.a.copy(ce.a),me.b.copy(ce.b),me.c.copy(ce.c),h=!0)}}}if(h)return s&&(i.copy(ge),ce.a.copy(me.a),ce.b.copy(me.b),ce.c.copy(me.c)),i.applyMatrix4(e),null!==r&&(de.fromCoplanarPoints(ce.a,ce.b,ce.c),r.copy(de.normal),r.transformDirection(e)),i}return null}toTriangleSoup(){const t=this.indices;if(t){const e=this.vertices,s=new Float32Array(3*t.length);for(let i=0,r=t.length;i<r;i++){const r=t[i],n=3;s[i*n]=e[r*n],s[i*n+1]=e[r*n+1],s[i*n+2]=e[r*n+2]}return new fe(s)}return this}toJSON(){const t={type:this.constructor.name};return t.indices={type:this.indices?this.indices.constructor.name:"null",data:this.indices?Array.from(this.indices):null},t.vertices=Array.from(this.vertices),t.backfaceCulling=this.backfaceCulling,t.aabb=this.aabb.toJSON(),t.boundingSphere=this.boundingSphere.toJSON(),t}fromJSON(t){switch(this.aabb=(new ot).fromJSON(t.aabb),this.boundingSphere=(new at).fromJSON(t.boundingSphere),this.backfaceCulling=t.backfaceCulling,this.vertices=new Float32Array(t.vertices),t.indices.type){case"Uint16Array":this.indices=new Uint16Array(t.indices.data);break;case"Uint32Array":this.indices=new Uint32Array(t.indices.data);break;case"null":this.indices=null}return this}}class ye{constructor(){this._previousTime=0,this._currentTime=0,this._delta=0,this._elapsed=0,this._timescale=1,this._useFixedDelta=!1,this._fixedDelta=16.67,this._usePageVisibilityAPI="undefined"!=typeof document&&void 0!==document.hidden,!0===this._usePageVisibilityAPI&&(this._pageVisibilityHandler=xe.bind(this),document.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disableFixedDelta(){return this._useFixedDelta=!1,this}dispose(){return!0===this._usePageVisibilityAPI&&document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this}enableFixedDelta(){return this._useFixedDelta=!0,this}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getFixedDelta(){return this._fixedDelta/1e3}getTimescale(){return this._timescale}reset(){return this._currentTime=this._now(),this}setFixedDelta(t){return this._fixedDelta=1e3*t,this}setTimescale(t){return this._timescale=t,this}update(){return!0===this._useFixedDelta?this._delta=this._fixedDelta:(this._previousTime=this._currentTime,this._currentTime=this._now(),this._delta=this._currentTime-this._previousTime),this._delta*=this._timescale,this._elapsed+=this._delta,this}_now(){return("undefined"==typeof performance?Date:performance).now()}}function xe(){!1===document.hidden&&this.reset()}class we{enter(){}execute(){}exit(){}toJSON(){}fromJSON(){}resolveReferences(){}onMessage(){return!1}}class Se{clearDegreeOfMembership(){}getDegreeOfMembership(){}updateDegreeOfMembership(){}toJSON(){return{type:this.constructor.name}}}class ve extends Se{constructor(t=new Array){super(),this.terms=t}clearDegreeOfMembership(){const t=this.terms;for(let e=0,s=t.length;e<s;e++)t[e].clearDegreeOfMembership();return this}updateDegreeOfMembership(t){const e=this.terms;for(let s=0,i=e.length;s<i;s++)e[s].updateDegreeOfMembership(t);return this}toJSON(){const t=super.toJSON();t.terms=new Array;for(let e=0,s=this.terms.length;e<s;e++){const s=this.terms[e];s instanceof ve?t.terms.push(s.toJSON()):t.terms.push(s.uuid)}return t}}class be extends ve{constructor(){super(Array.from(arguments))}getDegreeOfMembership(){const t=this.terms;let e=1/0;for(let s=0,i=t.length;s<i;s++){const i=t[s].getDegreeOfMembership();i<e&&(e=i)}return e}}class _e extends ve{constructor(t=null){super(null!==t?[t]:new Array)}clearDegreeOfMembership(){return this.terms[0].clearDegreeOfMembership(),this}getDegreeOfMembership(){const t=this.terms[0].getDegreeOfMembership();return Math.sqrt(t)}updateDegreeOfMembership(t){return this.terms[0].updateDegreeOfMembership(Math.sqrt(t)),this}}class Me extends ve{constructor(){super(Array.from(arguments))}getDegreeOfMembership(){const t=this.terms;let e=-1/0;for(let s=0,i=t.length;s<i;s++){const i=t[s].getDegreeOfMembership();i>e&&(e=i)}return e}}class ze extends ve{constructor(t=null){super(null!==t?[t]:new Array)}clearDegreeOfMembership(){return this.terms[0].clearDegreeOfMembership(),this}getDegreeOfMembership(){const t=this.terms[0].getDegreeOfMembership();return t*t}updateDegreeOfMembership(t){return this.terms[0].updateDegreeOfMembership(t*t),this}}class Oe extends Se{constructor(t=0){super(),this.degreeOfMembership=0,this.representativeValue=t,this.left=0,this.right=0,this._uuid=null}get uuid(){return null===this._uuid&&(this._uuid=o.generateUUID()),this._uuid}computeDegreeOfMembership(){}clearDegreeOfMembership(){return this.degreeOfMembership=0,this}getDegreeOfMembership(){return this.degreeOfMembership}updateDegreeOfMembership(t){return t>this.degreeOfMembership&&(this.degreeOfMembership=t),this}toJSON(){const t=super.toJSON();return t.degreeOfMembership=this.degreeOfMembership,t.representativeValue=this.representativeValue,t.left=this.left,t.right=this.right,t.uuid=this.uuid,t}fromJSON(t){return this.degreeOfMembership=t.degreeOfMembership,this.representativeValue=t.representativeValue,this.left=t.left,this.right=t.right,this._uuid=t.uuid,this}}class Ae extends Oe{constructor(t=0,e=0,s=0){super((e+t)/2),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;if(t>=s&&t<=e)return 1;if(t>e&&t<=i){return 1/(i-e)*(i-t)}return 0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}function Ne(t,e,s){return 1/Math.sqrt(2*Math.PI*s)*Math.exp(-Math.pow(t-e,2)/(2*s))}class Te extends Oe{constructor(t=0,e=0,s=0){super((e+s)/2),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;if(t>=s&&t<=e){return 1/(e-s)*(t-s)}return t>e&&t<=i?1:0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class Je extends Oe{constructor(t=0,e=0,s=0){super(e),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.left,s=this.right;return t>=e&&t<=s?1:0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class De extends Oe{constructor(t=0,e=0,s=0){super(e),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;if(t>=s&&t<=e){return 1/(e-s)*(t-s)}if(t>e&&t<=i){return 1/(i-e)*(i-t)}return 0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class Pe{constructor(t=null,e=null){this.antecedent=t,this.consequence=e}initConsequence(){return this.consequence.clearDegreeOfMembership(),this}evaluate(){return this.consequence.updateDegreeOfMembership(this.antecedent.getDegreeOfMembership()),this}toJSON(){const t={},e=this.antecedent,s=this.consequence;return t.type=this.constructor.name,t.antecedent=e instanceof ve?e.toJSON():e.uuid,t.consequence=s instanceof ve?s.toJSON():s.uuid,t}fromJSON(t,e){function i(t){if("string"==typeof t){const s=t;return e.get(s)||null}{const e=t.type;let r;switch(e){case"FuzzyAND":r=new be;break;case"FuzzyOR":r=new Me;break;case"FuzzyVERY":r=new ze;break;case"FuzzyFAIRLY":r=new _e;break;default:return void s.error("YUKA.FuzzyRule: Unsupported operator type:",e)}const n=t.terms;for(let t=0,e=n.length;t<e;t++)r.terms.push(i(n[t]));return r}}return this.antecedent=i(t.antecedent),this.consequence=i(t.consequence),this}}class Ee{constructor(){this.fuzzySets=new Array,this.minRange=1/0,this.maxRange=-1/0}add(t){return this.fuzzySets.push(t),t.left<this.minRange&&(this.minRange=t.left),t.right>this.maxRange&&(this.maxRange=t.right),this}remove(t){const e=this.fuzzySets,s=e.indexOf(t);e.splice(s,1),this.minRange=1/0,this.maxRange=-1/0;for(let t=0,s=e.length;t<s;t++){const s=e[t];s.left<this.minRange&&(this.minRange=s.left),s.right>this.maxRange&&(this.maxRange=s.right)}return this}fuzzify(t){if(t<this.minRange||t>this.maxRange)return void s.warn("YUKA.FuzzyVariable: Value for fuzzification out of range.");const e=this.fuzzySets;for(let s=0,i=e.length;s<i;s++){const i=e[s];i.degreeOfMembership=i.computeDegreeOfMembership(t)}return this}defuzzifyMaxAv(){const t=this.fuzzySets;let e=0,s=0;for(let i=0,r=t.length;i<r;i++){const r=t[i];e+=r.degreeOfMembership,s+=r.representativeValue*r.degreeOfMembership}return 0===e?0:s/e}defuzzifyCentroid(t=10){const e=this.fuzzySets,s=(this.maxRange-this.minRange)/t;let i=0,r=0;for(let n=1;n<=t;n++){const t=this.minRange+n*s;for(let s=0,n=e.length;s<n;s++){const n=e[s],o=Math.min(n.degreeOfMembership,n.computeDegreeOfMembership(t));i+=o,r+=t*o}}return 0===i?0:r/i}toJSON(){const t={type:this.constructor.name,fuzzySets:new Array,minRange:this.minRange.toString(),maxRange:this.maxRange.toString()};for(let e=0,s=this.fuzzySets.length;e<s;e++){const s=this.fuzzySets[e];t.fuzzySets.push(s.toJSON())}return t}fromJSON(t){this.minRange=parseFloat(t.minRange),this.maxRange=parseFloat(t.maxRange);for(let e=0,i=t.fuzzySets.length;e<i;e++){const i=t.fuzzySets[e];switch(i.type){case"LeftShoulderFuzzySet":this.fuzzySets.push((new Ae).fromJSON(i));break;case"RightShoulderFuzzySet":this.fuzzySets.push((new Te).fromJSON(i));break;case"SingletonFuzzySet":this.fuzzySets.push((new Je).fromJSON(i));break;case"TriangularFuzzySet":this.fuzzySets.push((new De).fromJSON(i));break;default:s.error("YUKA.FuzzyVariable: Unsupported fuzzy set type:",i.type)}}return this}}class Re{constructor(){this.rules=new Array,this.flvs=new Map}addFLV(t,e){return this.flvs.set(t,e),this}removeFLV(t){return this.flvs.delete(t),this}addRule(t){return this.rules.push(t),this}removeRule(t){const e=this.rules,s=e.indexOf(t);return e.splice(s,1),this}fuzzify(t,e){return this.flvs.get(t).fuzzify(e),this}defuzzify(t,e=Re.DEFUZ_TYPE.MAXAV){const i=this.flvs,r=this.rules;this._initConsequences();for(let t=0,e=r.length;t<e;t++){r[t].evaluate()}const n=i.get(t);let o;switch(e){case Re.DEFUZ_TYPE.MAXAV:o=n.defuzzifyMaxAv();break;case Re.DEFUZ_TYPE.CENTROID:o=n.defuzzifyCentroid();break;default:s.warn("YUKA.FuzzyModule: Unknown defuzzification method:",e),o=n.defuzzifyMaxAv()}return o}_initConsequences(){const t=this.rules;for(let e=0,s=t.length;e<s;e++){t[e].initConsequence()}return this}toJSON(){const t={rules:new Array,flvs:new Array},e=this.rules;for(let s=0,i=e.length;s<i;s++)t.rules.push(e[s].toJSON());const s=this.flvs;for(let[e,i]of s)t.flvs.push({name:e,flv:i.toJSON()});return t}fromJSON(t){const e=new Map,s=t.flvs;for(let t=0,i=s.length;t<i;t++){const i=s[t],r=i.name,n=(new Ee).fromJSON(i.flv);this.addFLV(r,n);for(let t of n.fuzzySets)e.set(t.uuid,t)}const i=t.rules;for(let t=0,s=i.length;t<s;t++){const s=i[t],r=(new Pe).fromJSON(s,e);this.addRule(r)}return this}}Re.DEFUZ_TYPE=Object.freeze({MAXAV:0,CENTROID:1});class Fe{constructor(t=null){this.owner=t,this.status=Fe.STATUS.INACTIVE}activate(){}execute(){}terminate(){}handleMessage(){return!1}active(){return this.status===Fe.STATUS.ACTIVE}inactive(){return this.status===Fe.STATUS.INACTIVE}completed(){return this.status===Fe.STATUS.COMPLETED}failed(){return this.status===Fe.STATUS.FAILED}replanIfFailed(){return!0===this.failed()&&(this.status=Fe.STATUS.INACTIVE),this}activateIfInactive(){return!0===this.inactive()&&(this.status=Fe.STATUS.ACTIVE,this.activate()),this}toJSON(){return{type:this.constructor.name,owner:this.owner.uuid,status:this.status}}fromJSON(t){return this.owner=t.owner,this.status=t.status,this}resolveReferences(t){return this.owner=t.get(this.owner)||null,this}}Fe.STATUS=Object.freeze({ACTIVE:"active",INACTIVE:"inactive",COMPLETED:"completed",FAILED:"failed"});class ke extends Fe{constructor(t=null){super(t),this.subgoals=new Array}addSubgoal(t){return this.subgoals.unshift(t),this}removeSubgoal(t){const e=this.subgoals.indexOf(t);return this.subgoals.splice(e,1),this}clearSubgoals(){const t=this.subgoals;for(let e=0,s=t.length;e<s;e++){t[e].terminate()}return t.length=0,this}currentSubgoal(){const t=this.subgoals.length;return t>0?this.subgoals[t-1]:null}executeSubgoals(){const t=this.subgoals;for(let e=t.length-1;e>=0;e--){const s=t[e];if(!0!==s.completed()&&!0!==s.failed())break;s instanceof ke&&s.clearSubgoals(),s.terminate(),t.pop()}const e=this.currentSubgoal();return null!==e?(e.activateIfInactive(),e.execute(),!0===e.completed()&&t.length>1?Fe.STATUS.ACTIVE:e.status):Fe.STATUS.COMPLETED}hasSubgoals(){return this.subgoals.length>0}handleMessage(t){const e=this.currentSubgoal();return null!==e&&e.handleMessage(t)}toJSON(){const t=super.toJSON();t.subgoals=new Array;for(let e=0,s=this.subgoals.length;e<s;e++){const s=this.subgoals[e];t.subgoals.push(s.toJSON())}return t}resolveReferences(t){super.resolveReferences(t);for(let e=0,s=this.subgoals.length;e<s;e++){this.subgoals[e].resolveReferences(t)}return this}}class Ve{constructor(t=-1,e=-1,s=0){this.from=t,this.to=e,this.cost=s}copy(t){return this.from=t.from,this.to=t.to,this.cost=t.cost,this}clone(){return(new this.constructor).copy(this)}toJSON(){return{type:this.constructor.name,from:this.from,to:this.to,cost:this.cost}}fromJSON(t){return this.from=t.from,this.to=t.to,this.cost=t.cost,this}}class Ce{constructor(t=-1){this.index=t}toJSON(){return{type:this.constructor.name,index:this.index}}fromJSON(t){return this.index=t.index,this}}class Be{constructor(){this.digraph=!1,this._nodes=new Map,this._edges=new Map}addNode(t){const e=t.index;return this._nodes.set(e,t),this._edges.set(e,new Array),this}addEdge(t){let e;if(e=this._edges.get(t.from),e.push(t),!1===this.digraph){const s=t.clone();s.from=t.to,s.to=t.from,e=this._edges.get(t.to),e.push(s)}return this}getNode(t){return this._nodes.get(t)||null}getEdge(t,e){if(this.hasNode(t)&&this.hasNode(e)){const s=this._edges.get(t);for(let t=0,i=s.length;t<i;t++){const i=s[t];if(i.to===e)return i}}return null}getNodes(t){return t.length=0,t.push(...this._nodes.values()),t}getEdgesOfNode(t,e){const s=this._edges.get(t);return void 0!==s&&(e.length=0,e.push(...s)),e}getNodeCount(){return this._nodes.size}getEdgeCount(){let t=0;for(const e of this._edges.values())t+=e.length;return t}removeNode(t){if(this._nodes.delete(t.index),!1===this.digraph){const e=this._edges.get(t.index);for(const s of e){const e=this._edges.get(s.to);for(let s=e.length-1;s>=0;s--){const i=e[s];if(i.to===t.index){const t=e.indexOf(i);e.splice(t,1);break}}}}else for(const t of this._edges.values())for(let e=t.length-1;e>=0;e--){const s=t[e];if(!this.hasNode(s.to)||!this.hasNode(s.from)){const e=t.indexOf(s);t.splice(e,1)}}return this._edges.delete(t.index),this}removeEdge(t){const e=this._edges.get(t.from);if(void 0!==e){const s=e.indexOf(t);if(e.splice(s,1),!1===this.digraph){const e=this._edges.get(t.to);for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.to===t.from){const t=e.indexOf(i);e.splice(t,1);break}}}}return this}hasNode(t){return this._nodes.has(t)}hasEdge(t,e){if(this.hasNode(t)&&this.hasNode(e)){const s=this._edges.get(t);for(let t=0,i=s.length;t<i;t++){if(s[t].to===e)return!0}return!1}return!1}clear(){return this._nodes.clear(),this._edges.clear(),this}toJSON(){const t={type:this.constructor.name,digraph:this.digraph},e=new Array,s=new Array;for(let[t,i]of this._nodes.entries()){const r=new Array;this.getEdgesOfNode(t,r);for(let t=0,s=r.length;t<s;t++)e.push(r[t].toJSON());s.push(i.toJSON())}return t._edges=e,t._nodes=s,t}fromJSON(t){this.digraph=t.digraph;for(let e=0,s=t._nodes.length;e<s;e++)this.addNode((new Ce).fromJSON(t._nodes[e]));for(let e=0,s=t._edges.length;e<s;e++)this.addEdge((new Ve).fromJSON(t._edges[e]));return this}}class qe{static calculate(t,e,s){const i=t.getNode(e),r=t.getNode(s);return i.position.distanceTo(r.position)}}class Ie{constructor(t=Ue){this.data=new Array,this.length=0,this.compare=t}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return null;const t=this.data[0];return this.length--,this.length>0&&(this.data[0]=this.data[this.length],this._down(0)),this.data.pop(),t}peek(){return this.data[0]||null}_up(t){const e=this.data,s=this.compare,i=e[t];for(;t>0;){const r=t-1>>1,n=e[r];if(s(i,n)>=0)break;e[t]=n,t=r}e[t]=i}_down(t){const e=this.data,s=this.compare,i=e[t],r=this.length>>1;for(;t<r;){let r=1+(t<<1),n=r+1,o=e[r];if(n<this.length&&s(e[n],o)<0&&(r=n,o=e[n]),s(o,i)>=0)break;e[t]=o,t=r}e[t]=i}}function Ue(t,e){return t<e?-1:t>e?1:0}class Le{constructor(t=null,e=-1,s=-1){this.graph=t,this.source=e,this.target=s,this.found=!1,this.heuristic=qe,this._cost=new Map,this._shortestPathTree=new Map,this._searchFrontier=new Map}search(){const t=new Array,e=new Ie(Ye);for(e.push({cost:0,index:this.source});e.length>0;){const s=e.pop().index;if(!this._shortestPathTree.has(s)){if(!0===this._searchFrontier.has(s)&&this._shortestPathTree.set(s,this._searchFrontier.get(s)),s===this.target)return this.found=!0,this;this.graph.getEdgesOfNode(s,t);for(let i=0,r=t.length;i<r;i++){const r=t[i],n=(this._cost.get(s)||0)+r.cost,o=n+this.heuristic.calculate(this.graph,r.to,this.target);(!1===this._searchFrontier.has(r.to)||n<this._cost.get(r.to))&&(this._cost.set(r.to,n),this._searchFrontier.set(r.to,r),e.push({cost:o,index:r.to}))}}}return this.found=!1,this}getPath(){const t=new Array;if(!1===this.found||-1===this.target)return t;let e=this.target;for(t.push(e);e!==this.source;)e=this._shortestPathTree.get(e).from,t.unshift(e);return t}getSearchTree(){return[...this._shortestPathTree.values()]}clear(){return this.found=!1,this._cost.clear(),this._shortestPathTree.clear(),this._searchFrontier.clear(),this}}function Ye(t,e){return t.cost<e.cost?-1:t.cost>e.cost?1:0}function He(t,e){return t.cost<e.cost?-1:t.cost>e.cost?1:0}const We=new h,je=new h,Ke=new h,Ge=new h(1,0,0),Ze=new h(0,1,0),Xe=new h(0,0,1),Qe={a:new h,b:new h,c:new h},$e=new h,ts=new Array;class es{constructor(){this.parent=null,this.children=new Array,this.boundingVolume=new ot,this.primitives=new Array,this.centroids=new Array}root(){return null===this.parent}leaf(){return 0===this.children.length}getDepth(){let t=0,e=this.parent;for(;null!==e;)e=e.parent,t++;return t}traverse(t){t(this);for(let e=0,s=this.children.length;e<s;e++)this.children[e].traverse(t);return this}build(t,e,s,i){this.computeBoundingVolume();const r=this.primitives.length/9,n=Math.floor(r/t);if(i<=s&&n>=e){this.split(t);for(let r=0;r<t;r++)this.children[r].build(t,e,s,i+1)}return this}computeBoundingVolume(){const t=this.primitives,e=this.boundingVolume;e.min.set(1/0,1/0,1/0),e.max.set(-1/0,-1/0,-1/0);for(let s=0,i=t.length;s<i;s+=3)We.x=t[s],We.y=t[s+1],We.z=t[s+2],e.expand(We);return this}computeSplitAxis(){let t,e,s,i,r=e=t=-1/0,n=i=s=1/0;const o=this.centroids;for(let h=0,a=o.length;h<a;h+=3){const a=o[h],l=o[h+1],c=o[h+2];a>t&&(t=a),l>e&&(e=l),c>r&&(r=c),a<s&&(s=a),l<i&&(i=l),c<n&&(n=c)}const h=t-s,a=e-i,l=r-n;return h>a&&h>l?Ge:a>l?Ze:Xe}split(t){const e=this.centroids,s=this.primitives;for(let e=0;e<t;e++)this.children[e]=new es,this.children[e].parent=this;const i=this.computeSplitAxis(),r=new Array;for(let t=0,s=e.length;t<s;t+=3){We.fromArray(e,t);const s=We.dot(i),n=t/3;r.push({index:n,p:s})}r.sort(ss);const n=r.length,o=Math.floor(n/t);var h=0,a=0;for(let i=0;i<n;i++){++a>o&&h<t-1&&(a=1,h++);const n=this.children[h],l=r[i].index,c=9*l;We.fromArray(s,c),je.fromArray(s,c+3),Ke.fromArray(s,c+6),n.primitives.push(We.x,We.y,We.z),n.primitives.push(je.x,je.y,je.z),n.primitives.push(Ke.x,Ke.y,Ke.z),We.fromArray(e,3*l),n.centroids.push(We.x,We.y,We.z)}return this.centroids.length=0,this.primitives.length=0,this}intersectRay(t,e){if(null!==t.intersectAABB(this.boundingVolume,e))if(!0===this.leaf()){const s=this.primitives;for(let i=0,r=s.length;i<r;i+=9)Qe.a.fromArray(s,i),Qe.b.fromArray(s,i+3),Qe.c.fromArray(s,i+6),null!==t.intersectTriangle(Qe,!0,e)&&ts.push(e.clone())}else for(let s=0,i=this.children.length;s<i;s++)this.children[s].intersectRay(t,e);if(!0===this.root()){if(ts.length>0){let s=1/0;for(let i=0,r=ts.length;i<r;i++){const r=t.origin.squaredDistanceTo(ts[i]);r<s&&(s=r,e.copy(ts[i]))}return ts.length=0,e}return null}return null}intersectsRay(t){if(null!==t.intersectAABB(this.boundingVolume,$e)){if(!0===this.leaf()){const e=this.primitives;for(let s=0,i=e.length;s<i;s+=9)if(Qe.a.fromArray(e,s),Qe.b.fromArray(e,s+3),Qe.c.fromArray(e,s+6),null!==t.intersectTriangle(Qe,!0,$e))return!0;return!1}for(let e=0,s=this.children.length;e<s;e++)if(!0===this.children[e].intersectsRay(t))return!0;return!1}return!1}}function ss(t,e){return t.p-e.p}const is=new h,rs=new h;class ns{constructor(t=new h,e=new h){this.from=t,this.to=e}set(t,e){return this.from=t,this.to=e,this}copy(t){return this.from.copy(t.from),this.to.copy(t.to),this}clone(){return(new this.constructor).copy(this)}delta(t){return t.subVectors(this.to,this.from)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.from)}closestPointToPoint(t,e,s){const i=this.closestPointToPointParameter(t,e);return this.at(i,s)}closestPointToPointParameter(t,e=!0){is.subVectors(t,this.from),rs.subVectors(this.to,this.from);const s=rs.dot(rs);let i=rs.dot(is)/s;return e&&(i=o.clamp(i,0,1)),i}equals(t){return t.from.equals(this.from)&&t.to.equals(this.to)}}const os=new h,hs=new h,as=new h,ls=new h,cs=new h,us=new h,ds=new h;class ps{intersects(t,e){if(this._checkFaceDirections(t,e))return!1;if(this._checkFaceDirections(e,t))return!1;return!this._checkEdgeDirections(t,e)}_checkFaceDirections(t,e){const s=t.faces;for(let t=0,i=s.length;t<i;t++){const i=s[t].plane;hs.copy(i.normal).multiplyScalar(-1);const r=this._getSupportVertex(e,hs);if(i.distanceToPoint(r)>0)return!0}return!1}_checkEdgeDirections(t,e){const s=t.edges,i=e.edges;for(let e=0,r=s.length;e<r;e++){const r=s[e];for(let e=0,s=i.length;e<s;e++){const s=i[e];if(r.getDirection(as),s.getDirection(ls),this._minkowskiFace(r,as,s,ls)){if(this._distanceBetweenEdges(r,as,s,ls,t)>0)return!0}}}return!1}_getSupportVertex(t,e){let s=-1/0,i=null;const r=t.vertices;for(let t=0,n=r.length;t<n;t++){const n=r[t],o=n.dot(e);o>s&&(s=o,i=n)}return i}_minkowskiFace(t,e,s,i){const r=t.polygon.plane.normal,n=t.twin.polygon.plane.normal;cs.copy(s.polygon.plane.normal),us.copy(s.twin.polygon.plane.normal),cs.multiplyScalar(-1),us.multiplyScalar(-1);const o=cs.dot(e),h=us.dot(e),a=r.dot(i),l=n.dot(i);return o*h<0&&a*l<0&&o*l>0}_distanceBetweenEdges(t,e,s,i,r){return 1===Math.abs(e.dot(i))?-1/0:(os.crossVectors(e,i).normalize(),os.dot(ds.subVectors(t.vertex,r.centroid))<0&&os.multiplyScalar(-1),os.dot(ds.subVectors(s.vertex,t.vertex)))}}class gs{constructor(t=new h){this.vertex=t,this.next=null,this.prev=null,this.twin=null,this.polygon=null}tail(){return this.prev?this.prev.vertex:null}head(){return this.vertex}length(){const t=this.tail(),e=this.head();return null!==t?t.distanceTo(e):-1}squaredLength(){const t=this.tail(),e=this.head();return null!==t?t.squaredDistanceTo(e):-1}linkOpponent(t){return this.twin=t,t.twin=this,this}getDirection(t){return t.subVectors(this.vertex,this.prev.vertex).normalize()}}class ms{constructor(){this.centroid=new h,this.edge=null,this.plane=new ae}fromContour(t){const e=new Array;if(t.length<3)return s.error("YUKA.Polygon: Unable to create polygon from contour. It needs at least three points."),this;for(let s=0,i=t.length;s<i;s++){const i=new gs(t[s]);e.push(i)}for(let t=0,s=e.length;t<s;t++){let i,r,n;0===t?(i=e[t],r=e[s-1],n=e[t+1]):t===s-1?(i=e[t],r=e[t-1],n=e[0]):(i=e[t],r=e[t-1],n=e[t+1]),i.prev=r,i.next=n,i.polygon=this}return this.edge=e[0],this.plane.fromCoplanarPoints(t[0],t[1],t[2]),this}computeCentroid(){const t=this.centroid;let e=this.edge,s=0;t.set(0,0,0);do{t.add(e.vertex),s++,e=e.next}while(e!==this.edge);return t.divideScalar(s),this}contains(t,e=.001){const s=this.plane;let i=this.edge;do{if(!1===fs(i.tail(),i.head(),t))return!1;i=i.next}while(i!==this.edge);const r=s.distanceToPoint(t);return!(Math.abs(r)>e)}convex(t=!0){let e=this.edge;do{const s=e.tail(),i=e.head(),r=e.next.head();if(t){if(!1===fs(s,i,r))return!1}else if(!1===fs(r,i,s))return!1;e=e.next}while(e!==this.edge);return!0}coplanar(t=.001){const e=this.plane;let s=this.edge;do{const i=e.distanceToPoint(s.vertex);if(Math.abs(i)>t)return!1;s=s.next}while(s!==this.edge);return!0}distanceToPoint(t){return this.plane.distanceToPoint(t)}getContour(t){let e=this.edge;t.length=0;do{t.push(e.vertex),e=e.next}while(e!==this.edge);return t}}function fs(t,e,s){return o.area(t,e,s)>=0}class ys{constructor(){this.faces=new Array,this.edges=new Array,this.vertices=new Array,this.centroid=new h}computeCentroid(){const t=this.centroid;let e=this.faces;t.set(0,0,0);for(let s=0,i=e.length;s<i;s++){const i=e[s];t.add(i.centroid)}return t.divideScalar(e.length),this}computeUniqueVertices(){const t=this.faces,e=this.vertices;e.length=0;const s=new Set;for(let e=0,i=t.length;e<i;e++){const i=t[e];let r=i.edge;do{s.add(r.vertex),r=r.next}while(r!==i.edge)}return e.push(...s),this}computeUniqueEdges(){const t=this.faces,e=this.edges;e.length=0;for(let s=0,i=t.length;s<i;s++){const i=t[s];let r=i.edge;do{!1===e.includes(r.twin)&&e.push(r),r=r.next}while(r!==i.edge)}return this}fromAABB(t){this.faces.length=0,this.vertices.length=0;const e=t.min,s=t.max,i=[new h(s.x,s.y,s.z),new h(s.x,s.y,e.z),new h(s.x,e.y,s.z),new h(s.x,e.y,e.z),new h(e.x,s.y,s.z),new h(e.x,s.y,e.z),new h(e.x,e.y,s.z),new h(e.x,e.y,e.z)];this.vertices.push(...i);const r=(new ms).fromContour([i[4],i[0],i[1],i[5]]),n=(new ms).fromContour([i[2],i[3],i[1],i[0]]),o=(new ms).fromContour([i[6],i[2],i[0],i[4]]),a=(new ms).fromContour([i[3],i[7],i[5],i[1]]),l=(new ms).fromContour([i[3],i[2],i[6],i[7]]),c=(new ms).fromContour([i[7],i[6],i[4],i[5]]);return r.edge.linkOpponent(c.edge.prev),r.edge.next.linkOpponent(o.edge.prev),r.edge.next.next.linkOpponent(n.edge.prev),r.edge.prev.linkOpponent(a.edge.prev),l.edge.linkOpponent(a.edge.next),l.edge.next.linkOpponent(n.edge.next),l.edge.next.next.linkOpponent(o.edge.next),l.edge.prev.linkOpponent(c.edge.next),c.edge.linkOpponent(a.edge.next.next),a.edge.linkOpponent(n.edge.next.next),n.edge.linkOpponent(o.edge.next.next),o.edge.linkOpponent(c.edge.next.next),this.faces.push(r,n,o,a,l,c),r.computeCentroid(),n.computeCentroid(),o.computeCentroid(),a.computeCentroid(),l.computeCentroid(),c.computeCentroid(),t.getCenter(this.centroid),this.computeUniqueEdges(),this}}const xs=new ns,ws=new ae,Ss=new h,vs=new h(0,1,0),bs=new ps;let _s;class Ms extends ys{constructor(){super(),this.mergeFaces=!0,this._tolerance=-1,this._vertices=new Array,this._assigned=new As,this._unassigned=new As}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++)if(e[s].distanceToPoint(t)>this._tolerance)return!1;return!0}intersectsAABB(t){if(void 0===_s)_s=(new ys).fromAABB(t);else{const e=t.min,s=t.max,i=_s.vertices;i[0].set(s.x,s.y,s.z),i[1].set(s.x,s.y,e.z),i[2].set(s.x,e.y,s.z),i[3].set(s.x,e.y,e.z),i[4].set(e.x,s.y,s.z),i[5].set(e.x,s.y,e.z),i[6].set(e.x,e.y,s.z),i[7].set(e.x,e.y,e.z),t.getCenter(_s.centroid)}return bs.intersects(this,_s)}intersectsConvexHull(t){return bs.intersects(this,t)}fromPoints(t){if(t.length<4)return s.error("YUKA.ConvexHull: The given points array needs at least four points."),this;for(let e=0,s=t.length;e<s;e++)this._vertices.push(new Os(t[e]));return this._generate(),this}_addAdjoiningFace(t,e){const s=new zs(t.point,e.prev.vertex,e.vertex);return this.faces.push(s),s.getEdge(-1).linkOpponent(e.twin),s.getEdge(0)}_addNewFaces(t,e){const s=[];let i=null,r=null;for(let n=0,o=e.length;n<o;n++){let o=this._addAdjoiningFace(t,e[n]);null===i?i=o:o.next.linkOpponent(r),s.push(o.polygon),r=o}return i.next.linkOpponent(r),s}_addVertexToFace(t,e){return t.face=e,null===e.outside?(this._assigned.append(t),e.outside=t):this._assigned.insertAfter(e.outside,t),this}_addVertexToHull(t){const e=[];this._unassigned.clear(),this._computeHorizon(t.point,null,t.face,e);const s=this._addNewFaces(t,e);return this._resolveUnassignedPoints(s),this}_reset(){return this._vertices.length=0,this._assigned.clear(),this._unassigned.clear(),this}_computeInitialHull(){let t,e,s,i;const r=this._vertices,n=this._computeExtremes(),o=n.min,h=n.max;let a,l;l=h.x.point.x-o.x.point.x,t=o.x,e=h.x,a=h.y.point.y-o.y.point.y,a>l&&(t=o.y,e=h.y,l=a),a=h.z.point.z-o.z.point.z,a>l&&(t=o.z,e=h.z),l=-1/0,xs.set(t.point,e.point);for(let i=0,n=r.length;i<n;i++){const n=r[i];n!==t&&n!==e&&(xs.closestPointToPoint(n.point,!0,Ss),a=Ss.squaredDistanceTo(n.point),a>l&&(l=a,s=n))}l=-1/0,ws.fromCoplanarPoints(t.point,e.point,s.point);for(let n=0,o=r.length;n<o;n++){const o=r[n];o!==t&&o!==e&&o!==s&&(a=Math.abs(ws.distanceToPoint(o.point)),a>l&&(l=a,i=o))}if(0===ws.distanceToPoint(i.point))throw"ERROR: YUKA.ConvexHull: All extreme points lie in a single plane. Unable to compute convex hull.";const c=this.faces;ws.distanceToPoint(i.point)<0?(c.push(new zs(t.point,e.point,s.point),new zs(i.point,e.point,t.point),new zs(i.point,s.point,e.point),new zs(i.point,t.point,s.point)),c[1].getEdge(2).linkOpponent(c[0].getEdge(1)),c[2].getEdge(2).linkOpponent(c[0].getEdge(2)),c[3].getEdge(2).linkOpponent(c[0].getEdge(0)),c[1].getEdge(1).linkOpponent(c[2].getEdge(0)),c[2].getEdge(1).linkOpponent(c[3].getEdge(0)),c[3].getEdge(1).linkOpponent(c[1].getEdge(0))):(c.push(new zs(t.point,s.point,e.point),new zs(i.point,t.point,e.point),new zs(i.point,e.point,s.point),new zs(i.point,s.point,t.point)),c[1].getEdge(2).linkOpponent(c[0].getEdge(0)),c[2].getEdge(2).linkOpponent(c[0].getEdge(2)),c[3].getEdge(2).linkOpponent(c[0].getEdge(1)),c[1].getEdge(0).linkOpponent(c[2].getEdge(1)),c[2].getEdge(0).linkOpponent(c[3].getEdge(1)),c[3].getEdge(0).linkOpponent(c[1].getEdge(1)));for(let n=0,o=r.length;n<o;n++){const o=r[n];if(o!==t&&o!==e&&o!==s&&o!==i){l=this._tolerance;let t=null;for(let e=0;e<4;e++)a=c[e].distanceToPoint(o.point),a>l&&(l=a,t=c[e]);null!==t&&this._addVertexToFace(o,t)}}return this}_computeExtremes(){const t=new h(1/0,1/0,1/0),e=new h(-1/0,-1/0,-1/0),s={x:null,y:null,z:null},i={x:null,y:null,z:null};for(let r=0,n=this._vertices.length;r<n;r++){const n=this._vertices[r],o=n.point;o.x<t.x&&(t.x=o.x,s.x=n),o.y<t.y&&(t.y=o.y,s.y=n),o.z<t.z&&(t.z=o.z,s.z=n),o.x>e.x&&(e.x=o.x,i.x=n),o.y>e.y&&(e.y=o.y,i.y=n),o.z>e.z&&(e.z=o.z,i.z=n)}return this._tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}_computeHorizon(t,e,s,i){if(s.outside){const t=s.outside;this._removeAllVerticesFromFace(s),this._unassigned.appendChain(t)}let r;s.active=!1,r=null===e?e=s.getEdge(0):e.next;do{let e=r.twin,s=e.polygon;s.active&&(s.distanceToPoint(t)>this._tolerance?this._computeHorizon(t,e,s,i):i.push(r)),r=r.next}while(r!==e);return this}_generate(){let t;for(this.faces.length=0,this._computeInitialHull();t=this._nextVertexToAdd();)this._addVertexToHull(t);return this._updateFaces(),this._postprocessHull(),this._reset(),this}_postprocessHull(){const t=this.faces,e=this.edges;if(!0===this.mergeFaces){const s={leftPrev:null,leftNext:null,rightPrev:null,rightNext:null};this.computeUniqueEdges(),e.sort(((t,e)=>e.length()-t.length()));for(let i=0,r=e.length;i<r;i++){const r=e[i];if(!1===this._mergePossible(r))continue;let n=r;s.prev=n.prev,s.next=n.next,s.prevTwin=n.twin.prev,s.nextTwin=n.twin.next,n.prev.next=n.twin.next,n.next.prev=n.twin.prev,n.twin.prev.next=n.next,n.twin.next.prev=n.prev;const o=n.polygon;o.edge=n.prev;const h=o.plane.normal.dot(vs)>=0;if(!0===o.convex(h)&&!0===o.coplanar(this._tolerance)){let e=o.edge;do{e.polygon=o,e=e.next}while(e!==o.edge);const s=t.indexOf(r.twin.polygon);t.splice(s,1)}else s.prev.next=n,s.next.prev=n,s.prevTwin.next=n.twin,s.nextTwin.prev=n.twin,o.edge=n}for(let e=0,s=t.length;e<s;e++)t[e].computeCentroid()}return this.computeCentroid(),this.computeUniqueEdges(),this.computeUniqueVertices(),this}_mergePossible(t){const e=t.polygon;let s=t.twin;do{if(s!==t.twin&&s.twin.polygon===e)return!1;s=s.next}while(t.twin!==s);return!0}_nextVertexToAdd(){let t=null;if(!1===this._assigned.empty()){let e=0,s=this._assigned.first();const i=s.face;do{const r=i.distanceToPoint(s.point);r>e&&(e=r,t=s),s=s.next}while(null!==s&&s.face===i)}return t}_updateFaces(){const t=this.faces,e=new Array;for(let s=0,i=t.length;s<i;s++){const i=t[s];i.active&&e.push(i)}return this.faces.length=0,this.faces.push(...e),this}_removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;e.face=null;let s=t.outside;for(;null!==s.next&&s.next.face===t;)s=s.next,s.face=null;t.outside=null,this._assigned.removeChain(e,s)}return this}_removeVertexFromFace(t,e){return t.face=null,t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this._assigned.remove(t),this}_resolveUnassignedPoints(t){if(!1===this._unassigned.empty()){let e=this._unassigned.first();do{let s=e.next,i=this._tolerance,r=null;for(let s=0,n=t.length;s<n;s++){const n=t[s];if(n.active){const t=n.distanceToPoint(e.point);t>i&&(i=t,r=n)}}null!==r&&this._addVertexToFace(e,r),e=s}while(null!==e)}return this}}class zs extends ms{constructor(t=new h,e=new h,s=new h){super(),this.outside=null,this.active=!0,this.fromContour([t,e,s]),this.computeCentroid()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}}class Os{constructor(t=new h){this.point=t,this.prev=null,this.next=null,this.face=null}}class As{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next?e.next.prev=e:this.tail=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,t.prev=null,t.next=null,this}removeChain(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,t.prev=null,e.next=null,this}empty(){return null===this.head}}const Ns={unitary:new f,diagonal:new f},Ts={c:null,u:[new h,new h,new h],e:[]},Js={c:null,u:[new h,new h,new h],e:[]},Ds=[[],[],[]],Ps=[[],[],[]],Es=[],Rs=new h,Fs=new h,ks=new h,Vs=new h,Cs=new h;class Bs{constructor(t=new h,e=new h,s=new f){this.center=t,this.halfSizes=e,this.rotation=s}set(t,e,s){return this.center=t,this.halfSizes=e,this.rotation=s,this}copy(t){return this.center.copy(t.center),this.halfSizes.copy(t.halfSizes),this.rotation.copy(t.rotation),this}clone(){return(new this.constructor).copy(this)}getSize(t){return t.copy(this.halfSizes).multiplyScalar(2)}clampPoint(t,e){const s=this.halfSizes;Vs.subVectors(t,this.center),this.rotation.extractBasis(Rs,Fs,ks),e.copy(this.center);const i=o.clamp(Vs.dot(Rs),-s.x,s.x);e.add(Rs.multiplyScalar(i));const r=o.clamp(Vs.dot(Fs),-s.y,s.y);e.add(Fs.multiplyScalar(r));const n=o.clamp(Vs.dot(ks),-s.z,s.z);return e.add(ks.multiplyScalar(n)),e}containsPoint(t){return Vs.subVectors(t,this.center),this.rotation.extractBasis(Rs,Fs,ks),Math.abs(Vs.dot(Rs))<=this.halfSizes.x&&Math.abs(Vs.dot(Fs))<=this.halfSizes.y&&Math.abs(Vs.dot(ks))<=this.halfSizes.z}intersectsAABB(t){return this.intersectsOBB(qs.fromAABB(t))}intersectsBoundingSphere(t){return this.clampPoint(t.center,Cs),Cs.squaredDistanceTo(t.center)<=t.radius*t.radius}intersectsOBB(t,e=Number.EPSILON){Ts.c=this.center,Ts.e[0]=this.halfSizes.x,Ts.e[1]=this.halfSizes.y,Ts.e[2]=this.halfSizes.z,this.rotation.extractBasis(Ts.u[0],Ts.u[1],Ts.u[2]),Js.c=t.center,Js.e[0]=t.halfSizes.x,Js.e[1]=t.halfSizes.y,Js.e[2]=t.halfSizes.z,t.rotation.extractBasis(Js.u[0],Js.u[1],Js.u[2]);for(let t=0;t<3;t++)for(let e=0;e<3;e++)Ds[t][e]=Ts.u[t].dot(Js.u[e]);Vs.subVectors(Js.c,Ts.c),Es[0]=Vs.dot(Ts.u[0]),Es[1]=Vs.dot(Ts.u[1]),Es[2]=Vs.dot(Ts.u[2]);for(let t=0;t<3;t++)for(let s=0;s<3;s++)Ps[t][s]=Math.abs(Ds[t][s])+e;let s,i;for(let t=0;t<3;t++)if(s=Ts.e[t],i=Js.e[0]*Ps[t][0]+Js.e[1]*Ps[t][1]+Js.e[2]*Ps[t][2],Math.abs(Es[t])>s+i)return!1;for(let t=0;t<3;t++)if(s=Ts.e[0]*Ps[0][t]+Ts.e[1]*Ps[1][t]+Ts.e[2]*Ps[2][t],i=Js.e[t],Math.abs(Es[0]*Ds[0][t]+Es[1]*Ds[1][t]+Es[2]*Ds[2][t])>s+i)return!1;return s=Ts.e[1]*Ps[2][0]+Ts.e[2]*Ps[1][0],i=Js.e[1]*Ps[0][2]+Js.e[2]*Ps[0][1],!(Math.abs(Es[2]*Ds[1][0]-Es[1]*Ds[2][0])>s+i)&&(s=Ts.e[1]*Ps[2][1]+Ts.e[2]*Ps[1][1],i=Js.e[0]*Ps[0][2]+Js.e[2]*Ps[0][0],!(Math.abs(Es[2]*Ds[1][1]-Es[1]*Ds[2][1])>s+i)&&(s=Ts.e[1]*Ps[2][2]+Ts.e[2]*Ps[1][2],i=Js.e[0]*Ps[0][1]+Js.e[1]*Ps[0][0],!(Math.abs(Es[2]*Ds[1][2]-Es[1]*Ds[2][2])>s+i)&&(s=Ts.e[0]*Ps[2][0]+Ts.e[2]*Ps[0][0],i=Js.e[1]*Ps[1][2]+Js.e[2]*Ps[1][1],!(Math.abs(Es[0]*Ds[2][0]-Es[2]*Ds[0][0])>s+i)&&(s=Ts.e[0]*Ps[2][1]+Ts.e[2]*Ps[0][1],i=Js.e[0]*Ps[1][2]+Js.e[2]*Ps[1][0],!(Math.abs(Es[0]*Ds[2][1]-Es[2]*Ds[0][1])>s+i)&&(s=Ts.e[0]*Ps[2][2]+Ts.e[2]*Ps[0][2],i=Js.e[0]*Ps[1][1]+Js.e[1]*Ps[1][0],!(Math.abs(Es[0]*Ds[2][2]-Es[2]*Ds[0][2])>s+i)&&(s=Ts.e[0]*Ps[1][0]+Ts.e[1]*Ps[0][0],i=Js.e[1]*Ps[2][2]+Js.e[2]*Ps[2][1],!(Math.abs(Es[1]*Ds[0][0]-Es[0]*Ds[1][0])>s+i)&&(s=Ts.e[0]*Ps[1][1]+Ts.e[1]*Ps[0][1],i=Js.e[0]*Ps[2][2]+Js.e[2]*Ps[2][0],!(Math.abs(Es[1]*Ds[0][1]-Es[0]*Ds[1][1])>s+i)&&(s=Ts.e[0]*Ps[1][2]+Ts.e[1]*Ps[0][2],i=Js.e[0]*Ps[2][1]+Js.e[1]*Ps[2][0],!(Math.abs(Es[1]*Ds[0][2]-Es[0]*Ds[1][2])>s+i)))))))))}intersectsPlane(t){this.rotation.extractBasis(Rs,Fs,ks);const e=this.halfSizes.x*Math.abs(t.normal.dot(Rs))+this.halfSizes.y*Math.abs(t.normal.dot(Fs))+this.halfSizes.z*Math.abs(t.normal.dot(ks)),s=t.normal.dot(this.center)-t.constant;return Math.abs(s)<=e}fromAABB(t){return t.getCenter(this.center),t.getSize(this.halfSizes).multiplyScalar(.5),this.rotation.identity(),this}fromPoints(t){const e=(new Ms).fromPoints(t).faces,s=new Array,i=new Array;for(let t=0,r=e.length;t<r;t++){const r=e[t];let n=r.edge;s.length=0;do{s.push(n),n=n.next}while(n!==r.edge);for(let t=1,e=s.length-2;t<=e;t++){const e=s[0].vertex,r=s[t+0].vertex,n=s[t+1].vertex;i.push(e.x,e.y,e.z),i.push(r.x,r.y,r.z),i.push(n.x,n.y,n.z)}}const r=new h,n=new h,o=new h,a=new h,l=new h,c=new h,u=new h,d=new h;let p,g,m,y,x,w,S=0;p=g=m=y=x=w=0;for(let t=0,e=i.length;t<e;t+=9){r.fromArray(i,t),n.fromArray(i,t+3),o.fromArray(i,t+6),u.set(0,0,0),u.add(r).add(n).add(o).divideScalar(3),a.subVectors(n,r),l.subVectors(o,r);const e=c.crossVectors(a,l).length()/2;d.add(c.copy(u).multiplyScalar(e)),S+=e,p+=(9*u.x*u.x+r.x*r.x+n.x*n.x+o.x*o.x)*(e/12),g+=(9*u.x*u.y+r.x*r.y+n.x*n.y+o.x*o.y)*(e/12),m+=(9*u.x*u.z+r.x*r.z+n.x*n.z+o.x*o.z)*(e/12),y+=(9*u.y*u.y+r.y*r.y+n.y*n.y+o.y*o.y)*(e/12),x+=(9*u.y*u.z+r.y*r.z+n.y*n.z+o.y*o.z)*(e/12),w+=(9*u.z*u.z+r.z*r.z+n.z*n.z+o.z*o.z)*(e/12)}d.divideScalar(S),p/=S,g/=S,m/=S,y/=S,x/=S,w/=S,p-=d.x*d.x,g-=d.x*d.y,m-=d.x*d.z,y-=d.y*d.y,x-=d.y*d.z,w-=d.z*d.z;const v=new f;v.elements[0]=p,v.elements[1]=g,v.elements[2]=m,v.elements[3]=g,v.elements[4]=y,v.elements[5]=x,v.elements[6]=m,v.elements[7]=x,v.elements[8]=w,v.eigenDecomposition(Ns);const b=Ns.unitary,_=new h,M=new h,z=new h;b.extractBasis(_,M,z);let O=-1/0,A=-1/0,N=-1/0,T=1/0,J=1/0,D=1/0;for(let e=0,s=t.length;e<s;e++){const s=t[e];O=Math.max(_.dot(s),O),A=Math.max(M.dot(s),A),N=Math.max(z.dot(s),N),T=Math.min(_.dot(s),T),J=Math.min(M.dot(s),J),D=Math.min(z.dot(s),D)}return _.multiplyScalar(.5*(T+O)),M.multiplyScalar(.5*(J+A)),z.multiplyScalar(.5*(D+N)),this.center.add(_).add(M).add(z),this.halfSizes.x=O-T,this.halfSizes.y=A-J,this.halfSizes.z=N-D,this.halfSizes.multiplyScalar(.5),this.rotation.copy(b),this}equals(t){return t.center.equals(this.center)&&t.halfSizes.equals(this.halfSizes)&&t.rotation.equals(this.rotation)}toJSON(){return{type:this.constructor.name,center:this.center.toArray(new Array),halfSizes:this.halfSizes.toArray(new Array),rotation:this.rotation.toArray(new Array)}}fromJSON(t){return this.center.fromArray(t.center),this.halfSizes.fromArray(t.halfSizes),this.rotation.fromArray(t.rotation),this}}const qs=new Bs;class Is extends Ve{constructor(t=-1,e=-1,s=0){super(t,e,s)}}class Us extends Ce{constructor(t=-1,e=new h,s={}){super(t),this.position=e,this.userData=s}}class Ls{constructor(){this.portalEdges=new Array}push(t,e){return this.portalEdges.push({left:t,right:e}),this}generate(){const t=this.portalEdges,e=new Array;let s,i,r,n=0,h=0,a=0;s=t[0].left,i=t[0].left,r=t[0].right,e.push(s);for(let l=1,c=t.length;l<c;l++){const c=t[l].left,u=t[l].right;if(o.area(s,r,u)<=0){if(!(s===r||o.area(s,i,u)>0)){e.push(i),s=i,n=h,i=s,r=s,h=n,a=n,l=n;continue}r=u,a=l}if(o.area(s,i,c)>=0){if(!(s===i||o.area(s,r,c)<0)){e.push(r),s=r,n=a,i=s,r=s,h=n,a=n,l=n;continue}i=c,h=l}}return 0!==e.length&&e[e.length-1]===t[t.length-1].left||e.push(t[t.length-1].left),e}}function Ys(t){let e=0;for(let s=0,i=t.length-1;s<i;s++){const i=t[s],r=t[s+1];e+=i.distanceTo(r)}return e}const Hs=new h,Ws=new h,js=new h,Ks=new h,Gs=new ns,Zs=new Array,Xs={edge:null,closestPoint:new h};class Qs{constructor(){this.graph=new Be,this.graph.digraph=!0,this.regions=new Array,this.spatialIndex=null,this.epsilonCoplanarTest=.001,this.epsilonContainsTest=1,this.mergeConvexRegions=!0,this._borderEdges=new Array}fromPolygons(t){this.clear();const e=new Array,s=new Array;for(let s=0,i=t.length;s<i;s++){const i=t[s];let r=i.edge;do{e.push(r),r=r.next}while(r!==i.edge);this.regions.push(i)}for(let t=0,i=e.length;t<i;t++){let i=e[t];if(null===i.twin)for(let r=t+1,n=e.length;r<n;r++){let t=e[r];if(i.tail().equals(t.head())&&i.head().equals(t.tail())){i.linkOpponent(t);const e=i.squaredLength();s.push({cost:e,edge:i});break}}}return s.sort($s),this._buildRegions(s),this._buildGraph(),this}clear(){return this.graph.clear(),this.regions.length=0,this.spatialIndex=null,this}getClosestRegion(t){const e=this.regions;let s=null,i=1/0;for(let r=0,n=e.length;r<n;r++){const n=e[r],o=t.squaredDistanceTo(n.centroid);o<i&&(i=o,s=n)}return s}getRandomRegion(){const t=this.regions;let e=Math.floor(Math.random()*t.length);return e===t.length&&(e=t.length-1),t[e]}getRegionForPoint(t,e=.001){let s;if(null!==this.spatialIndex){const e=this.spatialIndex.getIndexForPosition(t);s=this.spatialIndex.cells[e].entries}else s=this.regions;for(let i=0,r=s.length;i<r;i++){const r=s[i];if(!0===r.contains(t,e))return r}return null}getNodeIndex(t){return this.regions.indexOf(t)}findPath(t,e){const s=this.graph,i=new Array;let r=this.getRegionForPoint(t,this.epsilonContainsTest),n=this.getRegionForPoint(e,this.epsilonContainsTest);if(null!==r&&null!==n||(null===r&&(r=this.getClosestRegion(t)),null===n&&(n=this.getClosestRegion(e))),r===n)return i.push((new h).copy(t)),i.push((new h).copy(e)),i;{const o=this.getNodeIndex(r),h=this.getNodeIndex(n),a=new Le(s,o,h);if(a.search(),!0===a.found){const s=a.getPath(),r=new Ls;r.push(t,t);const n={left:null,right:null};for(let t=0,e=s.length-1;t<e;t++){const e=this.regions[s[t]],i=this.regions[s[t+1]];this._getPortalEdge(e,i,n),r.push(n.left,n.right)}r.push(e,e),i.push(...r.generate())}return i}}clampMovement(t,e,s,i){let r=this.getRegionForPoint(s,this.epsilonContainsTest);if(null===r){if(null===t)throw new Error("YUKA.NavMesh.clampMovement(): No current region available.");this._getClosestBorderEdge(e,Xs);const n=Xs.edge,o=Xs.closestPoint;n.getDirection(Ws);const h=js.subVectors(s,e).length();let a=0;0!==h&&(js.divideScalar(h),a=Ws.dot(js)),Ks.copy(o).add(Ws.multiplyScalar(a*h)),Gs.set(n.prev.vertex,n.vertex);const l=Gs.closestPointToPointParameter(Ks,!1);if(l>=0&&l<=1)i.copy(Ks);else{if(r=this.getRegionForPoint(Ks,this.epsilonContainsTest),null!==r)return i.copy(Ks),r;i.copy(e)}return t}return r}updateSpatialIndex(){if(null!==this.spatialIndex){this.spatialIndex.makeEmpty();const t=this.regions;for(let e=0,s=t.length;e<s;e++){const s=t[e];this.spatialIndex.addPolygon(s)}}return this}_buildRegions(t){const e=this.regions,s={leftPrev:null,leftNext:null,rightPrev:null,rightNext:null};if(!0===this.mergeConvexRegions)for(let i=0,r=t.length;i<r;i++){const r=t[i];let n=r.edge;s.prev=n.prev,s.next=n.next,s.prevTwin=n.twin.prev,s.nextTwin=n.twin.next,n.prev.next=n.twin.next,n.next.prev=n.twin.prev,n.twin.prev.next=n.next,n.twin.next.prev=n.prev;const o=n.polygon;if(o.edge=n.prev,!0===o.convex()&&!0===o.coplanar(this.epsilonCoplanarTest)){let t=o.edge;do{t.polygon=o,t=t.next}while(t!==o.edge);const s=e.indexOf(r.edge.twin.polygon);e.splice(s,1)}else s.prev.next=n,s.next.prev=n,s.prevTwin.next=n.twin,s.nextTwin.prev=n.twin,o.edge=n}for(let t=0,s=e.length;t<s;t++){const s=e[t];s.computeCentroid();let i=s.edge;do{null===i.twin&&this._borderEdges.push(i),i=i.next}while(i!==s.edge)}}_buildGraph(){const t=this.graph,e=this.regions,s=new Array;for(let i=0,r=e.length;i<r;i++){const r=e[i],n=new Array;s.push(n);let o=r.edge;do{if(null!==o.twin){const e=this.getNodeIndex(o.twin.polygon);if(n.push(e),!1===t.hasNode(this.getNodeIndex(o.polygon))){const e=new Us(this.getNodeIndex(o.polygon),o.polygon.centroid);t.addNode(e)}}o=o.next}while(o!==r.edge)}for(let e=0,i=s.length;e<i;e++){const i=s[e],r=e;for(let e=0,s=i.length;e<s;e++){const s=i[e];if(r!==s&&!1===t.hasEdge(r,s)){const e=t.getNode(r),i=t.getNode(s),n=e.position.distanceTo(i.position);t.addEdge(new Is(r,s,n))}}}return this}_getClosestBorderEdge(t,e){let s,i=1/0;if(null!==this.spatialIndex){Zs.length=0;const e=this.spatialIndex.getIndexForPosition(t),i=this.spatialIndex.cells[e].entries;for(let t=0,e=i.length;t<e;t++){const e=i[t];let s=e.edge;do{null===s.twin&&Zs.push(s),s=s.next}while(s!==e.edge)}s=Zs}else s=this._borderEdges;for(let r=0,n=s.length;r<n;r++){const n=s[r];Gs.set(n.prev.vertex,n.vertex);const o=Gs.closestPointToPointParameter(t);Gs.at(o,Hs);const h=Hs.squaredDistanceTo(t);h<i&&(i=h,e.edge=n,e.closestPoint.copy(Hs))}return this}_getPortalEdge(t,e,s){let i=t.edge;do{if(null!==i.twin&&i.twin.polygon===e)return s.left=i.prev.vertex,s.right=i.vertex,s;i=i.next}while(i!==t.edge);return s.left=null,s.right=null,s}}function $s(t,e){return t.cost<e.cost?1:t.cost>e.cost?-1:0}class ti{constructor(){this.json=null,this.path=null,this.cache=new Map,this.extensions=new Map}parse(t,e,s){return this.json=t,this.path=e,this.getDependency("mesh",0).then((t=>{const e=this.parseGeometry(t),i=new Qs;return s&&(void 0!==s.epsilonCoplanarTest&&(i.epsilonCoplanarTest=s.epsilonCoplanarTest),void 0!==s.mergeConvexRegions&&(i.mergeConvexRegions=s.mergeConvexRegions)),i.fromPolygons(e)}))}parseGeometry(t){const e=t.index,s=t.position,i=new Array,r=new Array;for(let t=0,e=s.length;t<e;t+=3){const e=new h;e.x=s[t+0],e.y=s[t+1],e.z=s[t+2],i.push(e)}if(e)for(let t=0,s=e.length;t<s;t+=3){const s=e[t+0],n=e[t+1],o=e[t+2],h=[i[s],i[n],i[o]],a=(new ms).fromContour(h);r.push(a)}else for(let t=0,e=i.length;t<e;t+=3){const e=[i[t+0],i[t+1],i[t+2]],s=(new ms).fromContour(e);r.push(s)}return r}getDependencies(t){const e=this.cache;let s=e.get(t);if(!s){const i=this.json[t+("mesh"===t?"es":"s")]||new Array;s=Promise.all(i.map(((e,s)=>this.getDependency(t,s)))),e.set(t,s)}return s}getDependency(t,e){const s=this.cache,i=t+":"+e;let r=s.get(i);if(void 0===r){switch(t){case"accessor":r=this.loadAccessor(e);break;case"buffer":r=this.loadBuffer(e);break;case"bufferView":r=this.loadBufferView(e);break;case"mesh":r=this.loadMesh(e);break;default:throw new Error("Unknown type: "+t)}s.set(i,r)}return r}loadBuffer(t){const e=this.json.buffers[t];return void 0===e.uri&&0===t?Promise.resolve(this.extensions.get("BINARY").body):new Promise(((t,i)=>{const r=(n=e.uri,o=this.path,"string"!=typeof n||""===n?"":/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n)?n:o+n);var n,o;fetch(r).then((t=>t.arrayBuffer())).then((e=>{t(e)})).catch((t=>{s.error("YUKA.NavMeshLoader: Unable to load buffer.",t),i(t)}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((t=>{const s=e.byteLength||0,i=e.byteOffset||0;return t.slice(i,i+s)}))}loadAccessor(t){const e=this.json.accessors[t];return this.getDependency("bufferView",e.bufferView).then((t=>{const s=ei[e.type];return new(0,si[e.componentType])(t,e.byteOffset||0,e.count*s)}))}loadMesh(t){const e=this.json.meshes[t];return this.getDependencies("accessor").then((t=>{const s=e.primitives[0];if(void 0!==s.mode&&4!==s.mode)throw new Error("YUKA.NavMeshLoader: Invalid geometry format. Please ensure to represent your geometry as triangles.");return{index:t[s.indices],position:t[s.attributes.POSITION],normal:t[s.attributes.NORMAL]}}))}parseBinary(t){const e=new DataView(t,ri);let s=0;const i=new TextDecoder;let r=null,n=null;for(;s<e.byteLength;){const o=e.getUint32(s,!0);s+=4;const h=e.getUint32(s,!0);if(s+=4,h===ni.JSON){const e=new Uint8Array(t,ri+s,o);r=i.decode(e)}else if(h===ni.BIN){const e=ri+s;n=t.slice(e,e+o)}s+=o}this.extensions.set("BINARY",{content:r,body:n})}}const ei={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},si={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ii="glTF",ri=12,ni={JSON:1313821514,BIN:5130562};class oi{constructor(t=new ot){this.aabb=t,this.entries=new Array}add(t){return this.entries.push(t),this}remove(t){const e=this.entries.indexOf(t);return this.entries.splice(e,1),this}makeEmpty(){return this.entries.length=0,this}empty(){return 0===this.entries.length}intersects(t){return this.aabb.intersectsAABB(t)}toJSON(){const t={type:this.constructor.name,aabb:this.aabb.toJSON(),entries:new Array},e=this.entries;for(let s=0,i=e.length;s<i;s++)t.entries.push(e[s].uuid);return t}fromJSON(t){return this.aabb.fromJSON(t.aabb),this.entries=t.entries.slice(),this}resolveReferences(t){const e=this.entries;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s]);return this}}const hi=new h,ai=new ot,li=new Array;class ci{constructor(t=null){this.entity=t,this.timeBecameVisible=-1/0,this.timeLastSensed=-1/0,this.lastSensedPosition=new h,this.visible=!1}toJSON(){return{type:this.constructor.name,entity:this.entity.uuid,timeBecameVisible:this.timeBecameVisible.toString(),timeLastSensed:this.timeLastSensed.toString(),lastSensedPosition:this.lastSensedPosition.toArray(new Array),visible:this.visible}}fromJSON(t){return this.entity=t.entity,this.timeBecameVisible=parseFloat(t.timeBecameVisible),this.timeLastSensed=parseFloat(t.timeLastSensed),this.lastSensedPosition.fromArray(t.lastSensedPosition),this.visible=t.visible,this}resolveReferences(t){return this.entity=t.get(this.entity)||null,this}}const ui=new h,di=new h,pi=new yt,gi=new h,mi=new h;const fi=new h,yi=new h,xi=new h,wi=new ns,Si=new h;function vi(t){const e=this.tasks;for(;t.timeRemaining()>0&&e.length>0;){e[0].execute(),e.shift()}e.length>0?(this._taskHandle=requestIdleCallback(this._handler,this.options),this._active=!0):(this._taskHandle=0,this._active=!1)}t.AABB=ot,t.AStar=Le,t.AlignmentBehavior=F,t.ArriveBehavior=C,t.BFS=class{constructor(t=null,e=-1,s=-1){this.graph=t,this.source=e,this.target=s,this.found=!1,this._route=new Map,this._visited=new Set,this._spanningTree=new Set}search(){const t=new Array,e=new Array,s=new Ve(this.source,this.source);for(t.push(s),this._visited.add(this.source);t.length>0;){const i=t.shift();if(this._route.set(i.to,i.from),i!==s&&this._spanningTree.add(i),i.to===this.target)return this.found=!0,this;this.graph.getEdgesOfNode(i.to,e);for(let s=0,i=e.length;s<i;s++){const i=e[s];!1===this._visited.has(i.to)&&(t.push(i),this._visited.add(i.to))}}return this.found=!1,this}getPath(){const t=new Array;if(!1===this.found||-1===this.target)return t;let e=this.target;for(t.push(e);e!==this.source;)e=this._route.get(e),t.unshift(e);return t}getSearchTree(){return[...this._spanningTree]}clear(){return this.found=!1,this._route.clear(),this._visited.clear(),this._spanningTree.clear(),this}},t.BVH=class{constructor(t=2,e=1,s=10){this.branchingFactor=t,this.primitivesPerNode=e,this.depth=s,this.root=null}fromMeshGeometry(t){this.root=new es,null!==t.indices&&(t=t.toTriangleSoup());const e=t.vertices;for(let t=0,s=e.length;t<s;t++)this.root.primitives.push(e[t]);const s=this.root.primitives;for(let t=0,e=s.length;t<e;t+=9)We.fromArray(s,t),je.fromArray(s,t+3),Ke.fromArray(s,t+6),We.add(je).add(Ke).divideScalar(3),this.root.centroids.push(We.x,We.y,We.z);return this.root.build(this.branchingFactor,this.primitivesPerNode,this.depth,1),this}traverse(t){return this.root.traverse(t),this}},t.BVHNode=es,t.BoundingSphere=at,t.CHFace=zs,t.CHVertex=Os,t.CHVertexList=As,t.Cell=oi,t.CellSpacePartitioning=class{constructor(t,e,s,i,r,n){this.cells=new Array,this.width=t,this.height=e,this.depth=s,this.cellsX=i,this.cellsY=r,this.cellsZ=n,this._halfWidth=this.width/2,this._halfHeight=this.height/2,this._halfDepth=this.depth/2,this._min=new h(-this._halfWidth,-this._halfHeight,-this._halfDepth),this._max=new h(this._halfWidth,this._halfHeight,this._halfDepth);const o=this.width/this.cellsX,a=this.height/this.cellsY,l=this.depth/this.cellsZ;for(let t=0;t<this.cellsX;t++){const e=t*o-this._halfWidth;for(let t=0;t<this.cellsY;t++){const s=t*a-this._halfHeight;for(let t=0;t<this.cellsZ;t++){const i=t*l-this._halfDepth,r=new h,n=new h;r.set(e,s,i),n.x=r.x+o,n.y=r.y+a,n.z=r.z+l;const c=new ot(r,n),u=new oi(c);this.cells.push(u)}}}}updateEntity(t,e=-1){const s=this.getIndexForPosition(t.position);return e!==s&&(this.addEntityToPartition(t,s),-1!==e&&this.removeEntityFromPartition(t,e)),s}addEntityToPartition(t,e){return this.cells[e].add(t),this}removeEntityFromPartition(t,e){return this.cells[e].remove(t),this}getIndexForPosition(t){hi.copy(t).clamp(this._min,this._max);let e=Math.abs(Math.floor(this.cellsX*(hi.x+this._halfWidth)/this.width)),s=Math.abs(Math.floor(this.cellsY*(hi.y+this._halfHeight)/this.height)),i=Math.abs(Math.floor(this.cellsZ*(hi.z+this._halfDepth)/this.depth));return e===this.cellsX&&(e=this.cellsX-1),s===this.cellsY&&(s=this.cellsY-1),i===this.cellsZ&&(i=this.cellsZ-1),e*this.cellsY*this.cellsZ+s*this.cellsZ+i}query(t,e,s){const i=this.cells;s.length=0,ai.min.copy(t).subScalar(e),ai.max.copy(t).addScalar(e);for(let t=0,e=i.length;t<e;t++){const e=i[t];!1===e.empty()&&!0===e.intersects(ai)&&s.push(...e.entries)}return s}makeEmpty(){const t=this.cells;for(let e=0,s=t.length;e<s;e++)t[e].makeEmpty();return this}addPolygon(t){const e=this.cells;t.getContour(li),ai.fromPoints(li);for(let s=0,i=e.length;s<i;s++){const i=e[s];!0===i.intersects(ai)&&i.add(t)}return this}toJSON(){const t={type:this.constructor.name,cells:new Array,width:this.width,height:this.height,depth:this.depth,cellsX:this.cellsX,cellsY:this.cellsY,cellsZ:this.cellsZ,_halfWidth:this._halfWidth,_halfHeight:this._halfHeight,_halfDepth:this._halfDepth,_min:this._min.toArray(new Array),_max:this._max.toArray(new Array)};for(let e=0,s=this.cells.length;e<s;e++)t.cells.push(this.cells[e].toJSON());return t}fromJSON(t){this.cells.length=0,this.width=t.width,this.height=t.height,this.depth=t.depth,this.cellsX=t.cellsX,this.cellsY=t.cellsY,this.cellsZ=t.cellsZ,this._halfWidth=t._halfWidth,this._halfHeight=t._halfHeight,this._halfDepth=t._halfHeight,this._min.fromArray(t._min),this._max.fromArray(t._max);for(let e=0,s=t.cells.length;e<s;e++)this.cells.push((new oi).fromJSON(t.cells[e]));return this}resolveReferences(t){for(let e=0,s=this.cells.length;e<s;e++)this.cells[e].resolveReferences(t);return this}},t.CohesionBehavior=U,t.CompositeGoal=ke,t.ConvexHull=Ms,t.Corridor=Ls,t.CostTable=class{constructor(){this._nodeMap=new Map}init(t){const e=t.graph,s=new Array;this.clear(),e.getNodes(s);for(let e=0,i=s.length;e<i;e++){const i=s[e];for(let e=0,r=s.length;e<r;e++){const r=s[e],n=Ys(t.findPath(i.position,r.position));this.set(i.index,r.index,n)}}return this}clear(){return this._nodeMap.clear(),this}set(t,e,s){const i=this._nodeMap;!1===i.has(t)&&i.set(t,new Map);return i.get(t).set(e,s),this}get(t,e){return this._nodeMap.get(t).get(e)}size(){return this._nodeMap.size}toJSON(){const t={nodes:new Array};for(let[e,s]of this._nodeMap.entries())t.nodes.push({index:e,costs:Array.from(s)});return t}fromJSON(t){const e=t.nodes;for(let t=0,s=e.length;t<s;t++){const s=e[t],i=s.index,r=new Map(s.costs);this._nodeMap.set(i,r)}return this}},t.DFS=class{constructor(t=null,e=-1,s=-1){this.graph=t,this.source=e,this.target=s,this.found=!1,this._route=new Map,this._visited=new Set,this._spanningTree=new Set}search(){const t=new Array,e=new Array,s=new Ve(this.source,this.source);for(t.push(s);t.length>0;){const i=t.pop();if(this._route.set(i.to,i.from),this._visited.add(i.to),i!==s&&this._spanningTree.add(i),i.to===this.target)return this.found=!0,this;this.graph.getEdgesOfNode(i.to,e);for(let s=0,i=e.length;s<i;s++){const i=e[s];!1===this._visited.has(i.to)&&t.push(i)}}return this.found=!1,this}getPath(){const t=new Array;if(!1===this.found||-1===this.target)return t;let e=this.target;for(t.push(e);e!==this.source;)e=this._route.get(e),t.unshift(e);return t}getSearchTree(){return[...this._spanningTree]}clear(){return this.found=!1,this._route.clear(),this._visited.clear(),this._spanningTree.clear(),this}},t.Dijkstra=class{constructor(t=null,e=-1,s=-1){this.graph=t,this.source=e,this.target=s,this.found=!1,this._cost=new Map,this._shortestPathTree=new Map,this._searchFrontier=new Map}search(){const t=new Array,e=new Ie(He);for(e.push({cost:0,index:this.source});e.length>0;){const s=e.pop().index;if(!this._shortestPathTree.has(s)){if(!0===this._searchFrontier.has(s)&&this._shortestPathTree.set(s,this._searchFrontier.get(s)),s===this.target)return this.found=!0,this;this.graph.getEdgesOfNode(s,t);for(let i=0,r=t.length;i<r;i++){const r=t[i],n=(this._cost.get(s)||0)+r.cost;(!1===this._searchFrontier.has(r.to)||n<this._cost.get(r.to))&&(this._cost.set(r.to,n),this._searchFrontier.set(r.to,r),e.push({cost:n,index:r.to}))}}}return this.found=!1,this}getPath(){const t=new Array;if(!1===this.found||-1===this.target)return t;let e=this.target;for(t.push(e);e!==this.source;)e=this._shortestPathTree.get(e).from,t.unshift(e);return t}getSearchTree(){return[...this._shortestPathTree.values()]}clear(){return this.found=!1,this._cost.clear(),this._shortestPathTree.clear(),this._searchFrontier.clear(),this}},t.Edge=Ve,t.EntityManager=class{constructor(){this.entities=new Array,this.spatialIndex=null,this._triggers=new Array,this._indexMap=new Map,this._typesMap=new Map,this._messageDispatcher=new r}add(t){return this.entities.push(t),t.manager=this,this}remove(t){const e=this.entities.indexOf(t);return this.entities.splice(e,1),t.manager=null,this}clear(){return this.entities.length=0,this._messageDispatcher.clear(),this}getEntityByName(t){const e=this.entities;for(let s=0,i=e.length;s<i;s++){const i=e[s];if(i.name===t)return i}return null}update(t){const e=this.entities,s=this._triggers;for(let s=e.length-1;s>=0;s--){const i=e[s];this.updateEntity(i,t)}for(let t=s.length-1;t>=0;t--){const e=s[t];this.processTrigger(e)}return this._triggers.length=0,this._messageDispatcher.dispatchDelayedMessages(t),this}updateEntity(t,e){if(!0===t.active){this.updateNeighborhood(t),!1===t._started&&(t.start(),t._started=!0),t.update(e);const s=t.children;for(let t=s.length-1;t>=0;t--){const i=s[t];this.updateEntity(i,e)}if(t instanceof ie&&this._triggers.push(t),null!==this.spatialIndex){let e=this._indexMap.get(t)||-1;e=this.spatialIndex.updateEntity(t,e),this._indexMap.set(t,e)}const i=t._renderComponent,r=t._renderComponentCallback;null!==i&&null!==r&&r(t,i)}return this}updateNeighborhood(t){if(!0===t.updateNeighborhood){t.neighbors.length=0,null!==this.spatialIndex?this.spatialIndex.query(t.position,t.neighborhoodRadius,re):(re.length=0,re.push(...this.entities));const e=t.neighborhoodRadius*t.neighborhoodRadius;for(let s=0,i=re.length;s<i;s++){const i=re[s];if(t!==i&&!0===i.active){t.position.squaredDistanceTo(i.position)<=e&&t.neighbors.push(i)}}}return this}processTrigger(t){t.updateRegion();const e=this.entities;for(let s=e.length-1;s>=0;s--){const i=e[s];t!==i&&!0===i.active&&!0===i.canActivateTrigger&&t.check(i)}return this}sendMessage(t,e,s,i,r){return this._messageDispatcher.dispatch(t,e,s,i,r),this}toJSON(){const t={type:this.constructor.name,entities:new Array,_messageDispatcher:this._messageDispatcher.toJSON()};function e(s){t.entities.push(s.toJSON());for(let t=0,i=s.children.length;t<i;t++)e(s.children[t])}for(let t=0,s=this.entities.length;t<s;t++)e(this.entities[t]);return t}fromJSON(t){this.clear();const e=t.entities,i=t._messageDispatcher,r=new Map;for(let t=0,i=e.length;t<i;t++){const i=e[t],n=i.type;let o;switch(n){case"GameEntity":o=(new A).fromJSON(i);break;case"MovingEntity":o=(new D).fromJSON(i);break;case"Vehicle":o=(new Zt).fromJSON(i);break;case"Trigger":o=(new ie).fromJSON(i);break;default:const t=this._typesMap.get(n);if(void 0===t){s.warn("YUKA.EntityManager: Unsupported entity type:",n);continue}o=(new t).fromJSON(i)}r.set(o.uuid,o),null===o.parent&&this.add(o)}for(let t of r.values())t.resolveReferences(r);return this._messageDispatcher.fromJSON(i),this}registerType(t,e){return this._typesMap.set(t,e),this}},t.EvadeBehavior=K,t.EventDispatcher=class{constructor(){this._events=new Map}addEventListener(t,e){const s=this._events;!1===s.has(t)&&s.set(t,new Array);const i=s.get(t);-1===i.indexOf(e)&&i.push(e)}removeEventListener(t,e){const s=this._events.get(t);if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}}hasEventListener(t,e){const s=this._events.get(t);return void 0!==s&&-1!==s.indexOf(e)}dispatchEvent(t){const e=this._events.get(t.type);if(void 0!==e){t.target=this;for(let s=0,i=e.length;s<i;s++)e[s].call(this,t)}}},t.FleeBehavior=Y,t.FollowPathBehavior=Z,t.FuzzyAND=be,t.FuzzyCompositeTerm=ve,t.FuzzyFAIRLY=_e,t.FuzzyModule=Re,t.FuzzyOR=Me,t.FuzzyRule=Pe,t.FuzzySet=Oe,t.FuzzyTerm=Se,t.FuzzyVERY=ze,t.FuzzyVariable=Ee,t.GameEntity=A,t.Goal=Fe,t.GoalEvaluator=class{constructor(t=1){this.characterBias=t}calculateDesirability(){return 0}setGoal(){}toJSON(){return{type:this.constructor.name,characterBias:this.characterBias}}fromJSON(t){return this.characterBias=t.characterBias,this}},t.Graph=Be,t.GraphUtils=class{static createGridLayout(t,e){const s=new Be;s.digraph=!0;const i=t/2,r=t/e;let n=0;for(let t=0;t<=e;t++){const o=t*r-i;for(let t=0;t<=e;t++){const e=new h(t*r-i,0,o),a=new Us(n,e);s.addNode(a),n++}}const o=s.getNodeCount(),a=Math.pow(r+r/2,2);for(let t=0;t<o;t++){const e=s.getNode(t);for(let i=0;i<o;i++)if(t!==i){const r=s.getNode(i).position.squaredDistanceTo(e.position);if(r<=a){const e=Math.sqrt(r),n=new Is(t,i,e);s.addEdge(n)}}}return s}},t.HalfEdge=gs,t.HeuristicPolicyDijkstra=class{static calculate(){return 0}},t.HeuristicPolicyEuclid=qe,t.HeuristicPolicyEuclidSquared=class{static calculate(t,e,s){const i=t.getNode(e),r=t.getNode(s);return i.position.squaredDistanceTo(r.position)}},t.HeuristicPolicyManhattan=class{static calculate(t,e,s){const i=t.getNode(e),r=t.getNode(s);return i.position.manhattanDistanceTo(r.position)}},t.InterposeBehavior=et,t.LeftSCurveFuzzySet=class extends Oe{constructor(t=0,e=0,s=0){super((e+t)/2),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;return t>=s&&t<=e?1:t>e&&t<=i?t>=(e+i)/2?2*Math.pow((t-i)/(e-i),2):1-2*Math.pow((t-e)/(e-i),2):0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}},t.LeftShoulderFuzzySet=Ae,t.LineSegment=ns,t.Logger=s,t.MathUtils=o,t.Matrix3=f,t.Matrix4=b,t.MemoryRecord=ci,t.MemorySystem=class{constructor(t=null){this.owner=t,this.records=new Array,this.recordsMap=new Map,this.memorySpan=1}getRecord(t){return this.recordsMap.get(t)}createRecord(t){const e=new ci(t);return this.records.push(e),this.recordsMap.set(t,e),this}deleteRecord(t){const e=this.getRecord(t),s=this.records.indexOf(e);return this.records.splice(s,1),this.recordsMap.delete(t),this}hasRecord(t){return this.recordsMap.has(t)}clear(){return this.records.length=0,this.recordsMap.clear(),this}getValidMemoryRecords(t,e){const s=this.records;e.length=0;for(let i=0,r=s.length;i<r;i++){const r=s[i];t-r.timeLastSensed<=this.memorySpan&&e.push(r)}return e}toJSON(){const t={type:this.constructor.name,owner:this.owner.uuid,records:new Array,memorySpan:this.memorySpan},e=this.records;for(let s=0,i=e.length;s<i;s++){const i=e[s];t.records.push(i.toJSON())}return t}fromJSON(t){this.owner=t.owner,this.memorySpan=t.memorySpan;const e=t.records;for(let t=0,s=e.length;t<s;t++){const s=e[t],i=(new ci).fromJSON(s);this.records.push(i)}return this}resolveReferences(t){this.owner=t.get(this.owner)||null;const e=this.records;for(let s=0,i=e.length;s<i;s++){const i=e[s];i.resolveReferences(t),this.recordsMap.set(i.entity,i)}return this}},t.MeshGeometry=fe,t.MessageDispatcher=r,t.MovingEntity=D,t.NavEdge=Is,t.NavMesh=Qs,t.NavMeshLoader=class{load(t,e){return new Promise(((i,r)=>{fetch(t).then((t=>{if(t.status>=200&&t.status<300)return t.arrayBuffer();{const e=new Error(t.statusText||t.status);return e.response=t,Promise.reject(e)}})).then((s=>this.parse(s,t,e))).then((t=>{i(t)})).catch((t=>{s.error("YUKA.NavMeshLoader: Unable to load navigation mesh.",t),r(t)}))}))}parse(t,e,s){const i=new ti,r=new TextDecoder;let n;r.decode(new Uint8Array(t,0,4))===ii?(i.parseBinary(t),n=i.extensions.get("BINARY").content):n=r.decode(new Uint8Array(t));const o=JSON.parse(n);if(void 0===o.asset||o.asset.version[0]<2)throw new Error("YUKA.NavMeshLoader: Unsupported asset version.");{const t=function(t=""){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}(e);return i.parse(o,t,s)}}},t.NavNode=Us,t.Node=Ce,t.NormalDistFuzzySet=class extends Oe{constructor(t=0,e=0,s=0,i=0){super(e),this.left=t,this.midpoint=e,this.right=s,this.standardDeviation=i,this._cache={}}computeDegreeOfMembership(t){return this._updateCache(),t>=this.right||t<=this.left?0:Ne(t,this.midpoint,this._cache.variance)/this._cache.normalizationFactor}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t.standardDeviation=this.standardDeviation,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this.standardDeviation=t.standardDeviation,this}_updateCache(){const t=this._cache,e=this.midpoint,s=this.standardDeviation;if(e!==t.midpoint||s!==t.standardDeviation){const i=s*s;t.midpoint=e,t.standardDeviation=s,t.variance=i,t.normalizationFactor=Ne(e,e,i)}return this}},t.OBB=Bs,t.ObstacleAvoidanceBehavior=zt,t.OffsetPursuitBehavior=Jt,t.OnPathBehavior=class extends P{constructor(t=new G,e=.1,s=1){super(),this.path=t,this.radius=e,this.predictionFactor=s,this._seek=new q}calculate(t,e){const s=this.path;fi.copy(t.velocity).multiplyScalar(this.predictionFactor),yi.addVectors(t.position,fi);let i=1/0,r=s._waypoints.length;r=!0===s.loop?r:r-1;for(let t=0;t<r;t++){wi.from=s._waypoints[t],!0===s.loop&&t===r-1?wi.to=s._waypoints[0]:wi.to=s._waypoints[t+1],wi.closestPointToPoint(yi,!0,xi);const e=yi.squaredDistanceTo(xi);e<i&&(i=e,Si.copy(xi))}return i>this.radius*this.radius&&s._waypoints.length>1&&(this._seek.target=Si,this._seek.calculate(t,e)),e}toJSON(){const t=super.toJSON();return t.path=this.path.toJSON(),t.radius=this.radius,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.path.fromJSON(t.path),this.radius=t.radius,this.predictionFactor=t.predictionFactor,this}},t.Path=G,t.Plane=ae,t.Polygon=ms,t.Polyhedron=ys,t.PriorityQueue=Ie,t.PursuitBehavior=kt,t.Quaternion=v,t.Ray=yt,t.RectangularTriggerRegion=te,t.Regulator=class{constructor(t=0){this.updateFrequency=t,this._time=new ye,this._nextUpdateTime=0}ready(){this._time.update();const t=this._time.getElapsed();return t>=this._nextUpdateTime&&(this._nextUpdateTime=t+1/this.updateFrequency,!0)}},t.RightSCurveFuzzySet=class extends Oe{constructor(t=0,e=0,s=0){super((e+s)/2),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;return t>=s&&t<=e?t<=(s+e)/2?2*Math.pow((t-s)/(e-s),2):1-2*Math.pow((t-e)/(e-s),2):t>e&&t<=i?1:0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}},t.RightShoulderFuzzySet=Te,t.SAT=ps,t.SeekBehavior=q,t.SeparationBehavior=Ct,t.SingletonFuzzySet=Je,t.Smoother=Yt,t.SphericalTriggerRegion=se,t.State=we,t.StateMachine=class{constructor(t=null){this.owner=t,this.currentState=null,this.previousState=null,this.globalState=null,this.states=new Map,this._typesMap=new Map}update(){return null!==this.globalState&&this.globalState.execute(this.owner),null!==this.currentState&&this.currentState.execute(this.owner),this}add(t,e){return e instanceof we?this.states.set(t,e):s.warn('YUKA.StateMachine: .add() needs a parameter of type "YUKA.State".'),this}remove(t){return this.states.delete(t),this}get(t){return this.states.get(t)}changeTo(t){const e=this.get(t);return this._change(e),this}revert(){return this._change(this.previousState),this}in(t){return this.get(t)===this.currentState}handleMessage(t){return null!==this.currentState&&!0===this.currentState.onMessage(this.owner,t)||null!==this.globalState&&!0===this.globalState.onMessage(this.owner,t)}toJSON(){const t={owner:this.owner.uuid,currentState:null,previousState:null,globalState:null,states:new Array},e=new Map;for(let[s,i]of this.states)t.states.push({type:i.constructor.name,id:s,state:i.toJSON()}),e.set(i,s);return t.currentState=e.get(this.currentState)||null,t.previousState=e.get(this.previousState)||null,t.globalState=e.get(this.globalState)||null,t}fromJSON(t){this.owner=t.owner;const e=t.states;for(let t=0,i=e.length;t<i;t++){const i=e[t],r=i.type,n=this._typesMap.get(r);if(void 0!==n){const t=i.id,e=(new n).fromJSON(i.state);this.add(t,e)}else s.warn("YUKA.StateMachine: Unsupported state type:",r)}return this.currentState=null!==t.currentState&&this.get(t.currentState)||null,this.previousState=null!==t.previousState&&this.get(t.previousState)||null,this.globalState=null!==t.globalState&&this.get(t.globalState)||null,this}resolveReferences(t){this.owner=t.get(this.owner)||null;for(let e of this.states.values())e.resolveReferences(t);return this}registerType(t,e){return this._typesMap.set(t,e),this}_change(t){this.previousState=this.currentState,null!==this.currentState&&this.currentState.exit(this.owner),this.currentState=t,this.currentState.enter(this.owner)}},t.SteeringBehavior=P,t.SteeringManager=Lt,t.Task=class{execute(){}},t.TaskQueue=class{constructor(){this.tasks=new Array,this.options={timeout:1e3},this._active=!1,this._handler=vi.bind(this),this._taskHandle=0}enqueue(t){return this.tasks.push(t),this}update(){return this.tasks.length>0?!1===this._active&&(this._taskHandle=requestIdleCallback(this._handler,this.options),this._active=!0):this._active=!1,this}},t.Telegram=e,t.Think=class extends ke{constructor(t=null){super(t),this.evaluators=new Array,this._typesMap=new Map}activate(){this.arbitrate()}execute(){this.activateIfInactive();const t=this.executeSubgoals();t!==Fe.STATUS.COMPLETED&&t!==Fe.STATUS.FAILED||(this.status=Fe.STATUS.INACTIVE)}terminate(){this.clearSubgoals()}addEvaluator(t){return this.evaluators.push(t),this}removeEvaluator(t){const e=this.evaluators.indexOf(t);return this.evaluators.splice(e,1),this}arbitrate(){const t=this.evaluators;let e=-1,i=null;for(let s=0,r=t.length;s<r;s++){const r=t[s];let n=r.calculateDesirability(this.owner);n*=r.characterBias,n>=e&&(e=n,i=r)}return null!==i?i.setGoal(this.owner):s.error("YUKA.Think: Unable to determine goal evaluator for game entity:",this.owner),this}toJSON(){const t=super.toJSON();t.evaluators=new Array;for(let e=0,s=this.evaluators.length;e<s;e++){const s=this.evaluators[e];t.evaluators.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t);const e=this._typesMap;this.evaluators.length=0,this.terminate();for(let i=0,r=t.evaluators.length;i<r;i++){const r=t.evaluators[i],n=r.type,o=e.get(n);if(void 0!==o){const t=(new o).fromJSON(r);this.evaluators.push(t)}else s.warn("YUKA.Think: Unsupported goal evaluator type:",n)}function i(t){const r=t.type,n=e.get(r);if(void 0!==n){const e=(new n).fromJSON(t),s=t.subgoals;if(void 0!==s)for(let t=0,r=s.length;t<r;t++){const r=i(s[t]);r&&e.subgoals.push(r)}return e}s.warn("YUKA.Think: Unsupported goal evaluator type:",r)}for(let e=0,s=t.subgoals.length;e<s;e++){const s=i(t.subgoals[e]);s&&this.subgoals.push(s)}return this}registerType(t,e){return this._typesMap.set(t,e),this}},t.Time=ye,t.TriangularFuzzySet=De,t.Trigger=ie,t.TriggerRegion=Xt,t.Vector3=h,t.Vehicle=Zt,t.Vision=class{constructor(t=null){this.owner=t,this.fieldOfView=Math.PI,this.range=1/0,this.obstacles=new Array}addObstacle(t){return this.obstacles.push(t),this}removeObstacle(t){const e=this.obstacles.indexOf(t);return this.obstacles.splice(e,1),this}visible(t){const e=this.owner,s=this.obstacles;e.getWorldPosition(mi),ui.subVectors(t,mi);const i=ui.length();if(i>this.range)return!1;e.getWorldDirection(di);if(di.angleTo(ui)>.5*this.fieldOfView)return!1;pi.origin.copy(mi),pi.direction.copy(ui).divideScalar(i||1);for(let t=0,e=s.length;t<e;t++){if(null!==s[t].lineOfSightTest(pi,gi)){if(gi.squaredDistanceTo(mi)<=i*i)return!1}}return!0}toJSON(){const t={type:this.constructor.name,owner:this.owner.uuid,fieldOfView:this.fieldOfView,range:this.range.toString()};t.obstacles=new Array;for(let e=0,s=this.obstacles.length;e<s;e++){const s=this.obstacles[e];t.obstacles.push(s.uuid)}return t}fromJSON(t){this.owner=t.owner,this.fieldOfView=t.fieldOfView,this.range=parseFloat(t.range);for(let e=0,s=t.obstacles.length;e<s;e++){const s=t.obstacles[e];this.obstacles.push(s)}return this}resolveReferences(t){this.owner=t.get(this.owner)||null;const e=this.obstacles;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s]);return this}},t.WanderBehavior=It,t.WorldUp=l,Object.defineProperty(t,"__esModule",{value:!0})}));
